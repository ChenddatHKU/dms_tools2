
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>dms_tools2.minimap2 &#8212; dms_tools2 2.6.5 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for dms_tools2.minimap2</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">===============</span>
<span class="sd">minimap2</span>
<span class="sd">===============</span>

<span class="sd">Runs `minimap2 &lt;https://lh3.github.io/minimap2/&gt;`_</span>
<span class="sd">aligner.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">packaging.version</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">Bio.SeqIO</span>

<span class="kn">from</span> <span class="nn">dms_tools2</span> <span class="kn">import</span> <span class="n">NTS</span>
<span class="kn">import</span> <span class="nn">dms_tools2.pacbio</span>
<span class="kn">import</span> <span class="nn">dms_tools2.seqnumbering</span>

<span class="c1">#: `options` argument to :class:`Mapper` that works well</span>
<span class="c1">#: for codon-mutant libraries such as those created for</span>
<span class="c1">#: deep mutational scanning. Indels are highly penalized</span>
<span class="c1">#: as they are not expected, and settings are used that</span>
<span class="c1">#: effectively call strings of consecutive nucleotide</span>
<span class="c1">#: mutations as expected during codon mutagenesis. The</span>
<span class="c1">#: queries are assumed to be in the same orientation as</span>
<span class="c1">#: the target.</span>
<span class="n">OPTIONS_CODON_DMS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--for-only&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;-A2&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;-B4&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;-O12&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;-E2&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;--secondary=no&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;--end-bonus=13&#39;</span><span class="p">,</span>
                    <span class="p">]</span>

<span class="c1">#: `options` argument to :class:`Mapper` that works well</span>
<span class="c1">#: for libraries that contain viral genes expected to</span>
<span class="c1">#: potentially have both point mutations (at nucleotide, not</span>
<span class="c1">#: codon level) and some longer deletions.</span>
<span class="c1">#: The queries are assumed to be in the same orientation</span>
<span class="c1">#: as the target. These options resemble those suggested for</span>
<span class="c1">#: `PacBio IsoSeq &lt;https://github.com/lh3/minimap2/blob/master/cookbook.md#map-iso-seq&gt;`_</span>
<span class="c1">#: but use `-C0` and `-un` to avoid splice-site preference as</span>
<span class="c1">#: we want to trick the aligner into thinking long deletions are</span>
<span class="c1">#: spliced introns.</span>
<span class="n">OPTIONS_VIRUS_W_DEL</span> <span class="o">=</span> <span class="p">[</span>
                       <span class="s1">&#39;-x&#39;</span><span class="p">,</span><span class="s1">&#39;splice&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;-un&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;-C0&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;--splice-flank=no&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;--mask-level=1&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;--secondary=no&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;--for-only&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;--end-seed-pen=2&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;--end-bonus=1&#39;</span><span class="p">,</span>
                      <span class="p">]</span>

<span class="c1"># namedtuple to hold alignments</span>
<span class="n">Alignment</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Alignment&#39;</span><span class="p">,</span>
        <span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="s1">&#39;r_st&#39;</span><span class="p">,</span> <span class="s1">&#39;r_en&#39;</span><span class="p">,</span> <span class="s1">&#39;r_len&#39;</span><span class="p">,</span> <span class="s1">&#39;q_len&#39;</span><span class="p">,</span> <span class="s1">&#39;q_st&#39;</span><span class="p">,</span>
         <span class="s1">&#39;q_en&#39;</span><span class="p">,</span> <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;cigar_str&#39;</span><span class="p">,</span> <span class="s1">&#39;additional&#39;</span><span class="p">,</span>
         <span class="s1">&#39;score&#39;</span><span class="p">])</span>
<span class="n">Alignment</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alignment of a query to a target.&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Name of target to which query was aligned.&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">r_st</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alignment start in target (0 based).&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">r_en</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alignment end in target (0 based).&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">r_len</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Total length of target prior to any clipping.&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">q_st</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alignment start in query (0 based).&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">q_en</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alignment end in query (0 based).&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">q_len</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Total length of query prior to any clipping.&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">strand</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;1 if aligns in forward polarity, -1 if in reverse.&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">cigar_str</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;CIGAR in `PAF long format &lt;https://github.com/lh3/minimap2#cs&gt;`_&quot;</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">additional</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;List of additional :class:`Alignment` &quot;</span>
        <span class="s2">&quot;objects, useful for multiple alignments.&quot;</span><span class="p">)</span>
<span class="n">Alignment</span><span class="o">.</span><span class="n">score</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;Alignment score.&#39;</span>


<div class="viewcode-block" id="checkAlignment"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.checkAlignment">[docs]</a><span class="k">def</span> <span class="nf">checkAlignment</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks alignment is valid given target and query.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        `a` (:class:`Alignment`)</span>
<span class="sd">            The alignment.</span>
<span class="sd">        `target` (str)</span>
<span class="sd">            The target to which `query` is aligned.</span>
<span class="sd">        `query` (str)</span>
<span class="sd">            The query aligned to `target`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        `True` if `a` is a valid alignment of `query`</span>
<span class="sd">        to `target`, `False` otherwise. Being valid does</span>
<span class="sd">        not mean an alignment is good, just that the</span>
<span class="sd">        start / ends and CIGAR in `a` are valid.</span>

<span class="sd">    &gt;&gt;&gt; target = &#39;ATGCAT&#39;</span>
<span class="sd">    &gt;&gt;&gt; query = &#39;TACA&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_valid = Alignment(target=&#39;target&#39;, r_st=1, r_en=5,</span>
<span class="sd">    ...         r_len=6, q_st=0, q_en=4, q_len=4, strand=1,</span>
<span class="sd">    ...         cigar_str=&#39;=T*ga=CA&#39;, additional=[], score=-1)</span>
<span class="sd">    &gt;&gt;&gt; checkAlignment(a_valid, target, query)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; a_invalid = a_valid._replace(r_st=0, r_en=4)</span>
<span class="sd">    &gt;&gt;&gt; checkAlignment(a_invalid, target, query)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; target = &#39;ATGCAT&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_valid2 = Alignment(target=&#39;target&#39;, r_st=0, r_en=6,</span>
<span class="sd">    ...         r_len=6, q_st=0, q_en=6, q_len=6, strand=1,</span>
<span class="sd">    ...         cigar_str=&#39;=A+tgc-tgc=AT&#39;, additional=[], score=-1)</span>
<span class="sd">    &gt;&gt;&gt; checkAlignment(a_valid2, target, target)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;not implemented for - strand&quot;</span>
    <span class="p">(</span><span class="n">cigar_query</span><span class="p">,</span> <span class="n">cigar_target</span><span class="p">)</span> <span class="o">=</span> <span class="n">cigarToQueryAndTarget</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">cigar_str</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">q_len</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">q_en</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">r_len</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">r_st</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">q_st</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">q_en</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">q_len</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">r_len</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">q_st</span> <span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">q_en</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cigar_query</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">r_st</span> <span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cigar_target</span><span class="p">)</span>
            <span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Mutations"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.Mutations">[docs]</a><span class="k">class</span> <span class="nc">Mutations</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class to hold mutations.</span>

<span class="sd">    Holds three types of mutations: substitutions (point mutations),</span>
<span class="sd">    insertions, and deletions.</span>

<span class="sd">    The numbering scheme used to define the mutations (e.g.,</span>
<span class="sd">    0-based, 1-based) is determined upstream when deciding how to</span>
<span class="sd">    number the mutations passed at initialization.</span>

<span class="sd">    When initializing, set Q-values to `math.nan` if they are</span>
<span class="sd">    not known. The Q-values are used to calculate accuracy</span>
<span class="sd">    of mutations via :meth:`dms_tools2.pacbio.qvalsToAccuracy`.</span>
<span class="sd">    Likewise, pass `math.nan` for homopolymer lengths if they</span>
<span class="sd">    are not known.</span>

<span class="sd">    Args:</span>
<span class="sd">        `substitution_tuples` (list)</span>
<span class="sd">            Substitutions `(i, mut_str, q)` where</span>
<span class="sd">            `i` is the site number, `mut_str` is a string</span>
<span class="sd">            describing substitution, and `q` is the Q-value.</span>
<span class="sd">        `insertion_tuples` (list)</span>
<span class="sd">            Insertions `(i, ins_len, mut_str, qs, hplen)` where `i`</span>
<span class="sd">            is site **after** insertion, `inslen` is insertion length,</span>
<span class="sd">            `mut_str` is string describing insertion, `qs` is</span>
<span class="sd">            numpy array of Q-values, and `hplen` is length of homopolymer</span>
<span class="sd">            in which insertion occurs.</span>
<span class="sd">        `deletion_tuples` (list)</span>
<span class="sd">            Deletions `(istart, iend, mut_str, q, hplen)` where</span>
<span class="sd">            `istart` is first site of deletion, `iend` is</span>
<span class="sd">            last site of deletion (so a single nucleotide</span>
<span class="sd">            deletion has `istart == iend`), `mut_str` is string</span>
<span class="sd">            describing deletion , `q` is the Q-value of the</span>
<span class="sd">            site immediately **after** the deletion in accordance with</span>
<span class="sd">            `PacBio CCS &lt;https://github.com/PacificBiosciences/unanimity/blob/develop/doc/PBCCS.md#interpretting-qual-values&gt;`_</span>
<span class="sd">            specification, and `hplen` is length of homopolymer</span>
<span class="sd">            in which deletion occurs.</span>
<span class="sd">        `acc_not_q` (bool)</span>
<span class="sd">            If `True`, then the tuples used to pass the mutations</span>
<span class="sd">            should give the accuracy rather than the Q-values.</span>

<span class="sd">    You can also create objects using :class:`Mutations.from_str`.</span>

<span class="sd">    After initialization, use the methods described below to get</span>
<span class="sd">    information about the mutations. All of the methods that</span>
<span class="sd">    return lists of mutations do them ordered by site (first to last).</span>

<span class="sd">    We keep track of the length of the homopolymers in which</span>
<span class="sd">    indels are found because the main error mode of PacBio</span>
<span class="sd">    sequencing is indels in homopolymers.</span>

<span class="sd">    Here is an example. Note that Q-value of 20 indicates an accuracy</span>
<span class="sd">    of 0.99, and a Q-value of 30 indicates an accuracy of 0.999:</span>

<span class="sd">    &gt;&gt;&gt; muts = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[(1, &#39;A1T&#39;, math.nan),</span>
<span class="sd">    ...             (15, &#39;C15A&#39;, 30), (13, &#39;G13A&#39;, 20)],</span>
<span class="sd">    ...         insertion_tuples=[(5, 2, &#39;ins5len2&#39;, [20, 30], 1)],</span>
<span class="sd">    ...         deletion_tuples=[(8, 10, &#39;del8to10&#39;, 20, 2)])</span>
<span class="sd">    &gt;&gt;&gt; muts.substitutions()</span>
<span class="sd">    [&#39;A1T&#39;, &#39;G13A&#39;, &#39;C15A&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.substitutions(returnval=&#39;site&#39;)</span>
<span class="sd">    [1, 13, 15]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions()</span>
<span class="sd">    [&#39;ins5len2&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions(returnval=&#39;site&#39;)</span>
<span class="sd">    [5]</span>
<span class="sd">    &gt;&gt;&gt; muts.deletions()</span>
<span class="sd">    [&#39;del8to10&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.deletions(returnval=&#39;site&#39;)</span>
<span class="sd">    [8]</span>

<span class="sd">    Now with some filtering on accuracy:</span>

<span class="sd">    &gt;&gt;&gt; muts.substitutions(min_acc=0.99)</span>
<span class="sd">    [&#39;G13A&#39;, &#39;C15A&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.substitutions(min_acc=0.995)</span>
<span class="sd">    [&#39;C15A&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions(min_acc=0.991)</span>
<span class="sd">    [&#39;ins5len2&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions(min_acc=0.999)</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; muts.deletions(min_acc=0.95)</span>
<span class="sd">    [&#39;del8to10&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.deletions(min_acc=0.999)</span>
<span class="sd">    []</span>

<span class="sd">    Now get lengths of insertions / deletions:</span>

<span class="sd">    &gt;&gt;&gt; muts.deletions(returnval=&#39;length&#39;)</span>
<span class="sd">    [3]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions(returnval=&#39;length&#39;)</span>
<span class="sd">    [2]</span>

<span class="sd">    Get homopolymer lengths:</span>

<span class="sd">    &gt;&gt;&gt; muts.deletions(returnval=&#39;homopolymer_length&#39;)</span>
<span class="sd">    [2]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions(returnval=&#39;homopolymer_length&#39;)</span>
<span class="sd">    [1]</span>

<span class="sd">    Show how we can get string representations with</span>
<span class="sd">    `repr` and `str`:</span>

<span class="sd">    &gt;&gt;&gt; str(muts) == repr(muts)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; str(muts)</span>
<span class="sd">    &#39;A1T; G13A (accuracy = 0.990000); C15A (accuracy = 0.999000); ins5len2 (accuracy = 0.994500, homopolymer length = 1); del8to10 (accuracy = 0.990000, homopolymer length = 2)&#39;</span>

<span class="sd">    Note that when Q-values or homopolymer lengths are not provided,</span>
<span class="sd">    then the aren&#39;t printed in the `str` representation:</span>

<span class="sd">    &gt;&gt;&gt; str(Mutations(substitution_tuples=[], insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[(8, 10, &#39;del8to10&#39;, math.nan, math.nan),</span>
<span class="sd">    ...                          (12, 14, &#39;del12to14&#39;, math.nan, 4)]))</span>
<span class="sd">    &#39;del8to10; del12to14 (homopolymer length = 4)&#39;</span>

<span class="sd">    Also show what these representations look like when there</span>
<span class="sd">    are no mutations:</span>

<span class="sd">    &gt;&gt;&gt; str(Mutations(substitution_tuples=[], insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[]))</span>
<span class="sd">    &#39;no mutations&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">substitution_tuples</span><span class="p">,</span> <span class="n">insertion_tuples</span><span class="p">,</span>
            <span class="n">deletion_tuples</span><span class="p">,</span> <span class="n">acc_not_q</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class doc string.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_substitution_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">substitution_tuples</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">acc_not_q</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">q</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">dms_tools2</span><span class="o">.</span><span class="n">pacbio</span><span class="o">.</span><span class="n">qvalsToAccuracy</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_substitution_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">acc</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_insertion_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">hplen</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">insertion_tuples</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">acc_not_q</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">qs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">dms_tools2</span><span class="o">.</span><span class="n">pacbio</span><span class="o">.</span><span class="n">qvalsToAccuracy</span><span class="p">(</span><span class="n">qs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hplen</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hplen</span><span class="p">):</span>
                <span class="n">hplen</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insertion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">hplen</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deletion_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">hplen</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">deletion_tuples</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">acc_not_q</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">q</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="n">dms_tools2</span><span class="o">.</span><span class="n">pacbio</span><span class="o">.</span><span class="n">qvalsToAccuracy</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hplen</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hplen</span><span class="p">):</span>
                <span class="n">hplen</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deletion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">hplen</span><span class="p">))</span>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">acc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitution_tuples</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">acc</span><span class="p">):</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mut_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{mut_str}</span><span class="s1"> (accuracy = </span><span class="si">{acc:.6f}</span><span class="s1">)&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">hplen</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insertion_tuples</span><span class="p">:</span>
            <span class="n">i_str</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">acc</span><span class="p">):</span>
                <span class="n">i_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;accuracy = </span><span class="si">{acc:.6f}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hplen</span><span class="p">):</span>
                <span class="n">i_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;homopolymer length = </span><span class="si">{hplen}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i_str</span><span class="p">:</span>
                <span class="n">i_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i_str</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{mut_str}</span><span class="s1"> (</span><span class="si">{i_str}</span><span class="s1">)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mut_str</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">hplen</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deletion_tuples</span><span class="p">:</span>
            <span class="n">i_str</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">acc</span><span class="p">):</span>
                <span class="n">i_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;accuracy = </span><span class="si">{acc:.6f}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hplen</span><span class="p">):</span>
                <span class="n">i_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;homopolymer length = </span><span class="si">{hplen}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i_str</span><span class="p">:</span>
                <span class="n">i_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i_str</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{mut_str}</span><span class="s1"> (</span><span class="si">{i_str}</span><span class="s1">)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mut_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;no mutations&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<div class="viewcode-block" id="Mutations.from_str"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.Mutations.from_str">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_str</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create :class:`Mutations` from str representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            `mut_str` (str)</span>
<span class="sd">                String representation as returned by `str(mut)`</span>
<span class="sd">                where `mut` is a :class:`Mutations` object.</span>
<span class="sd">                See the examples below for more details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Mutations` object.</span>

<span class="sd">        Examples of creating :class:`Mutations.from_str`.</span>
<span class="sd">        First, a single substitution without an accuracy:</span>

<span class="sd">        &gt;&gt;&gt; m = Mutations.from_str(&#39;A1T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; str(m)</span>
<span class="sd">        &#39;A1T&#39;</span>
<span class="sd">        &gt;&gt;&gt; str(m) == str(Mutations(substitution_tuples=[(1, &#39;A1T&#39;, math.nan)],</span>
<span class="sd">        ...         deletion_tuples=[], insertion_tuples=[]))</span>
<span class="sd">        True</span>

<span class="sd">        And now substitutions with Q-values:</span>

<span class="sd">        &gt;&gt;&gt; m2 = Mutations.from_str(&#39;A1T (accuracy = 0.99); G3A (accuracy = 0.999)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m2 == Mutations.from_str(str(m2))</span>
<span class="sd">        True</span>

<span class="sd">        Now including deletions:</span>

<span class="sd">        &gt;&gt;&gt; m3 = Mutations.from_str(</span>
<span class="sd">        ...         &#39;del1to3 (accuracy = 0.99); &#39;</span>
<span class="sd">        ...         &#39;A6T (accuracy = 0.995); &#39;</span>
<span class="sd">        ...         &#39;del8to9 (accuracy = 0.999, homopolymer length = 2)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; str(m3)</span>
<span class="sd">        &#39;A6T (accuracy = 0.995000); del1to3 (accuracy = 0.990000); del8to9 (accuracy = 0.999000, homopolymer length = 2)&#39;</span>

<span class="sd">        An insertion:</span>

<span class="sd">        &gt;&gt;&gt; m4 = Mutations.from_str(&#39;ins5len2 (accuracy = 0.99, homopolymer length = 3)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; str(m4)</span>
<span class="sd">        &#39;ins5len2 (accuracy = 0.990000, homopolymer length = 3)&#39;</span>

<span class="sd">        Example of a null mutation:</span>

<span class="sd">        &gt;&gt;&gt; m_null = Mutations.from_str(&#39;no mutations&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m_null2 = Mutations.from_str(&#39;&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m_null == m_null2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; str(m_null) == str(m_null2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; str(m_null)</span>
<span class="sd">        &#39;no mutations&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_tups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ins_tups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">del_tups</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">mut_str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mut_str</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">or</span> <span class="n">mut_str</span> <span class="o">==</span> <span class="s1">&#39;no mutations&#39;</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">sub_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                    <span class="sa">r</span><span class="s1">&#39;^(?P&lt;wt&gt;[ACGT])(?P&lt;i&gt;\d+)(?P&lt;mut&gt;[ACGT])&#39;</span>
                    <span class="sa">r</span><span class="s1">&#39;(?: \(accuracy = (?P&lt;acc&gt;\d+\.{0,1}\d*)\)){0,1}$&#39;</span><span class="p">)</span>

            <span class="n">del_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                    <span class="sa">r</span><span class="s1">&#39;^del(?P&lt;istart&gt;\d+)to(?P&lt;iend&gt;\d+)&#39;</span>
                    <span class="sa">r</span><span class="s1">&#39;(?: \((?:accuracy = (?P&lt;acc&gt;\d+\.{0,1}\d*)){0,1}(?:\, ){0,1}&#39;</span>
                    <span class="sa">r</span><span class="s1">&#39;(?:homopolymer length = (?P&lt;hplen&gt;\d+)){0,1}\)){0,1}$&#39;</span><span class="p">)</span>

            <span class="n">ins_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                    <span class="sa">r</span><span class="s1">&#39;ins(?P&lt;i&gt;\d+)len(?P&lt;ins_len&gt;\d+)&#39;</span>
                    <span class="sa">r</span><span class="s1">&#39;(?: \((?:accuracy = (?P&lt;acc&gt;\d+\.{0,1}\d*)){0,1}(?:\, ){0,1}&#39;</span>
                    <span class="sa">r</span><span class="s1">&#39;(?:homopolymer length = (?P&lt;hplen&gt;\d+)){0,1}\)){0,1}$&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">,</span> <span class="n">mut_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)):</span>

                <span class="n">m</span> <span class="o">=</span> <span class="n">sub_match</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">acc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;acc&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">acc</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">acc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
                    <span class="n">sub_tups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)),</span>
                            <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;mut&#39;</span><span class="p">),</span>
                            <span class="n">acc</span>
                            <span class="p">))</span>
                    <span class="k">continue</span>

                <span class="n">m</span> <span class="o">=</span> <span class="n">del_match</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">acc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;acc&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">acc</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">acc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
                    <span class="n">hplen</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;hplen&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">hplen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">hplen</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">hplen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hplen</span><span class="p">)</span>
                    <span class="n">del_tups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;istart&#39;</span><span class="p">)),</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;iend&#39;</span><span class="p">)),</span>
                            <span class="s1">&#39;del&#39;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;istart&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;to&#39;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;iend&#39;</span><span class="p">),</span>
                            <span class="n">acc</span><span class="p">,</span>
                            <span class="n">hplen</span>
                            <span class="p">))</span>
                    <span class="k">continue</span>

                <span class="n">m</span> <span class="o">=</span> <span class="n">ins_match</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">acc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;acc&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">acc</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">acc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
                    <span class="n">hplen</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;hplen&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">hplen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">hplen</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">hplen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hplen</span><span class="p">)</span>
                    <span class="n">ins_tups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)),</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;ins_len&#39;</span><span class="p">)),</span>
                            <span class="s1">&#39;ins&#39;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;len&#39;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;ins_len&#39;</span><span class="p">),</span>
                            <span class="n">acc</span><span class="p">,</span>
                            <span class="n">hplen</span>
                            <span class="p">))</span>
                    <span class="k">continue</span>

                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;could not match </span><span class="si">{s}</span><span class="s2"> in </span><span class="si">{mut_str}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;could not match </span><span class="si">{s}</span><span class="s2"> in </span><span class="si">{mut_str}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">substitution_tuples</span><span class="o">=</span><span class="n">sub_tups</span><span class="p">,</span>
                   <span class="n">insertion_tuples</span><span class="o">=</span><span class="n">ins_tups</span><span class="p">,</span>
                   <span class="n">deletion_tuples</span><span class="o">=</span><span class="n">del_tups</span><span class="p">,</span>
                   <span class="n">acc_not_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mutations.substitutions"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.Mutations.substitutions">[docs]</a>    <span class="k">def</span> <span class="nf">substitutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">returnval</span><span class="o">=</span><span class="s1">&#39;mutation&#39;</span><span class="p">,</span> <span class="n">min_acc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">min_acc_filter_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of substitutions or associated values.</span>

<span class="sd">        Args:</span>
<span class="sd">            `min_acc` (float or `None`)</span>
<span class="sd">                Only include substitutions with &gt;= this accuracy.</span>
<span class="sd">            `min_acc_filter_nan` (bool)</span>
<span class="sd">                If using `min_acc` filter, do we also remove</span>
<span class="sd">                mutations with an accuracy that is `math.nan`?</span>
<span class="sd">            `returnval` (str)</span>
<span class="sd">                Type of value to return in list:</span>

<span class="sd">                - &quot;mutation&quot;: Strings giving mutations, where</span>
<span class="sd">                  &quot;A1T&quot; means site 1 is mutated from A to T.</span>

<span class="sd">                - &quot;site&quot;: Sites of substitutions.</span>

<span class="sd">                - &quot;accuracy&quot;: Numbers giving accuracy of each</span>
<span class="sd">                  mutation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of mutations or other value specified by `returnval`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">min_acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subtups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitution_tuples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitution_tuples</span><span class="p">]</span>
            <span class="n">subtups</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span> <span class="k">for</span> <span class="n">tup</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_substitution_tuples</span><span class="p">,</span> <span class="n">accs</span><span class="p">)</span> <span class="k">if</span>
                    <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">min_acc</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="ow">not</span> <span class="n">min_acc_filter_nan</span><span class="p">)</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;mutation&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">subtups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;site&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">subtups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">subtups</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid `returnval` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">returnval</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mutations.insertions"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.Mutations.insertions">[docs]</a>    <span class="k">def</span> <span class="nf">insertions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">returnval</span><span class="o">=</span><span class="s1">&#39;mutation&#39;</span><span class="p">,</span> <span class="n">min_acc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">min_acc_filter_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of insertions.</span>

<span class="sd">        Args:</span>
<span class="sd">            `min_acc` (float or `None`)</span>
<span class="sd">                Only include insertions with &gt;= this accuracy.</span>
<span class="sd">            `min_acc_filter_nan` (bool)</span>
<span class="sd">                If using `min_acc` filter, do we also remove</span>
<span class="sd">                mutations with an accuracy that is `math.nan`?</span>
<span class="sd">            `returnval` (str)</span>
<span class="sd">                Type of value to return in list:</span>

<span class="sd">                - &quot;mutation&quot;: Strings giving mutations, where</span>
<span class="sd">                  &quot;ins10len20&quot; means insertion of length 20</span>
<span class="sd">                  immediately before site 10.</span>

<span class="sd">                - &quot;site&quot;: Sites of insertions.</span>

<span class="sd">                - &quot;length&quot;: Integers giving insertion lengths.</span>

<span class="sd">                - &quot;accuracy&quot;: Numbers giving accuracy of each</span>
<span class="sd">                  mutation. Accuracy of insertion is averaged</span>
<span class="sd">                  over its length.</span>

<span class="sd">                - &quot;homopolymer_length&quot;: Integers giving length</span>
<span class="sd">                  of homopolymer in which insertion is found.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of mutations or other value specified by `returnval`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">min_acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">instups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insertion_tuples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_insertion_tuples</span><span class="p">]</span>
            <span class="n">instups</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span> <span class="k">for</span> <span class="n">tup</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_insertion_tuples</span><span class="p">,</span> <span class="n">accs</span><span class="p">)</span> <span class="k">if</span>
                    <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">min_acc</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="ow">not</span> <span class="n">min_acc_filter_nan</span><span class="p">)</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;mutation&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">instups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;site&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">instups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">instups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">instups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;homopolymer_length&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">instups</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid `returnval` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">returnval</span><span class="p">))</span></div>


<div class="viewcode-block" id="Mutations.deletions"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.Mutations.deletions">[docs]</a>    <span class="k">def</span> <span class="nf">deletions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">returnval</span><span class="o">=</span><span class="s1">&#39;mutation&#39;</span><span class="p">,</span> <span class="n">min_acc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">min_acc_filter_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of deletions.</span>

<span class="sd">        Args:</span>
<span class="sd">            `min_acc` (float or `None`)</span>
<span class="sd">                Only include deletions with &gt;= this accuracy.</span>
<span class="sd">            `min_acc_filter_nan` (bool)</span>
<span class="sd">                If using `min_acc` filter, do we also remove</span>
<span class="sd">                mutations with an accuracy that is `math.nan`?</span>
<span class="sd">            `returnval` (str)</span>
<span class="sd">                Type of value to return in list:</span>

<span class="sd">                - &quot;mutation&quot;: Strings giving mutations, where</span>
<span class="sd">                  &quot;del12to13&quot; means deletion of nucleotides 12</span>
<span class="sd">                  to 13, inclusive.</span>

<span class="sd">                - &quot;site&quot;: Sites of where deletions start.</span>

<span class="sd">                - &quot;length&quot;: Integers giving deletion lengths.</span>

<span class="sd">                - &quot;accuracy&quot;: Numbers giving accuracy of each</span>
<span class="sd">                  mutation. Accuracy is for first nucleotide **after**</span>
<span class="sd">                  deletion.</span>

<span class="sd">                - &quot;homopolymer_length&quot;: Integers giving length</span>
<span class="sd">                  of homopolymer in which deletion is found.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of mutations or other value specified by `returnval`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">min_acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deltups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deletion_tuples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deletion_tuples</span><span class="p">]</span>
            <span class="n">deltups</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span> <span class="k">for</span> <span class="n">tup</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deletion_tuples</span><span class="p">,</span> <span class="n">accs</span><span class="p">)</span> <span class="k">if</span>
                    <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">min_acc</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="ow">not</span> <span class="n">min_acc_filter_nan</span><span class="p">)</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;mutation&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">deltups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;site&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">deltups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">deltups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">deltups</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">returnval</span> <span class="o">==</span> <span class="s1">&#39;homopolymer_length&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">deltups</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid `returnval` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">returnval</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="MutationCaller"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.MutationCaller">[docs]</a><span class="k">class</span> <span class="nc">MutationCaller</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Call :class:`Mutations` from :class:`Alignment`.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        `mapper` (:class:`Mapper`)</span>
<span class="sd">            The :class:`Mapper` used to create the alignments.</span>
<span class="sd">        `transcriptconverter` (:class:`dms_tools2.seqnumbering.TranscriptConverter` or `None`)</span>
<span class="sd">            Use if the alignments made by `mapper` are to transcripts</span>
<span class="sd">            (or partial transcripts) and you want to convert the numbering</span>
<span class="sd">            of mutations to 1, 2, ... numbering of the chromosomes</span>
<span class="sd">            containing these transcripts, plus indicate amino-acid</span>
<span class="sd">            substitutions in any CDSs. The target names in `mapper` should</span>
<span class="sd">            match the mRNA names in `transcriptconverter`. If you</span>
<span class="sd">            use a `transcriptconverter`, `targetindex` must be 1.</span>
<span class="sd">        `targetindex` (int)</span>
<span class="sd">            Number assigned to first nucleotide of target when</span>
<span class="sd">            numbering mutations. A value of 1 means that the first</span>
<span class="sd">            nucleotide of the target is position 1.</span>
<span class="sd">        `target_clip` (int)</span>
<span class="sd">            Ignore any mutations that occur within this many</span>
<span class="sd">            nucleotides of the termini of target. If an indel</span>
<span class="sd">            includes any nucleotides that are not ignored,</span>
<span class="sd">            then the full indel is reported.</span>
<span class="sd">        `query_softclip` (int)</span>
<span class="sd">            Ignore any mutations that occur within this many</span>
<span class="sd">            nucleotides of the termini of the query **and**</span>
<span class="sd">            are soft clipped in the alignment. If an indel</span>
<span class="sd">            includes any nucleotides not ignored, then the full</span>
<span class="sd">            indel is reported.</span>

<span class="sd">    Here is an example. First, create an :class:`Alignment`</span>
<span class="sd">    that corresponds to the following::</span>

<span class="sd">        target: --ATGCATGAAT--CGAAT</span>
<span class="sd">        query:  cgATGaAcG--TatCt---</span>

<span class="sd">    &gt;&gt;&gt; with tempfile.NamedTemporaryFile(mode=&#39;w&#39;) as targetfile:</span>
<span class="sd">    ...         _ = targetfile.write(&#39;&gt;target\\nATGCATGGATCGAAT&#39;)</span>
<span class="sd">    ...         targetfile.flush()</span>
<span class="sd">    ...         mapper = Mapper(targetfile.name, OPTIONS_CODON_DMS)</span>
<span class="sd">    &gt;&gt;&gt; a = Alignment(q_st=2, q_en=14, q_len=14, strand=1,</span>
<span class="sd">    ...         r_st=0, r_en=12, r_len=15, score=16, target=&#39;target&#39;,</span>
<span class="sd">    ...         cigar_str=&#39;=ATG*ca=A*tc=G-aa=T+at=C*gt&#39;, additional=[])</span>

<span class="sd">    Also create some Q-values. Just to make things simple for this</span>
<span class="sd">    example, we use unrealistic Q-values. For aligned sites they</span>
<span class="sd">    are equal to the site number in the target; for un-aligned sites</span>
<span class="sd">    they are 50.</span>

<span class="sd">    &gt;&gt;&gt; qvals = numpy.array([50, 50, 1, 2, 3, 4, 5, 6, 7, 10, 50, 50, 11, 12])</span>

<span class="sd">    Now call mutations using :class:`MutationCaller.call`:</span>

<span class="sd">    &gt;&gt;&gt; mutcaller = MutationCaller(mapper)</span>
<span class="sd">    &gt;&gt;&gt; muts = mutcaller.call(a, qvals)</span>
<span class="sd">    &gt;&gt;&gt; muts.substitutions()</span>
<span class="sd">    [&#39;C4A&#39;, &#39;T6C&#39;, &#39;G12T&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.substitutions(returnval=&#39;site&#39;)</span>
<span class="sd">    [4, 6, 12]</span>
<span class="sd">    &gt;&gt;&gt; muts.deletions()</span>
<span class="sd">    [&#39;del8to9&#39;, &#39;del13to15&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.deletions(returnval=&#39;site&#39;)</span>
<span class="sd">    [8, 13]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions()</span>
<span class="sd">    [&#39;ins1len2&#39;, &#39;ins11len2&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions(returnval=&#39;site&#39;)</span>
<span class="sd">    [1, 11]</span>

<span class="sd">    Check that homo-polymer lengths are correct:</span>

<span class="sd">    &gt;&gt;&gt; muts.deletions(returnval=&#39;homopolymer_length&#39;)</span>
<span class="sd">    [2, 2]</span>
<span class="sd">    &gt;&gt;&gt; muts.insertions(returnval=&#39;homopolymer_length&#39;)</span>
<span class="sd">    [1, 1]</span>

<span class="sd">    Check that Q-values are also correct:</span>

<span class="sd">    &gt;&gt;&gt; numpy.allclose(muts.substitutions(returnval=&#39;accuracy&#39;),</span>
<span class="sd">    ...     list(map(dms_tools2.pacbio.qvalsToAccuracy, [4, 6, 12])))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(muts.insertions(returnval=&#39;accuracy&#39;), list(</span>
<span class="sd">    ...     map(dms_tools2.pacbio.qvalsToAccuracy, [[50, 50], [50, 50]])))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(muts.deletions(returnval=&#39;accuracy&#39;),</span>
<span class="sd">    ...     [dms_tools2.pacbio.qvalsToAccuracy(10), math.nan], equal_nan=True)</span>
<span class="sd">    True</span>

<span class="sd">    Illustrate `targetindex` by re-calling with 0-based idexing:</span>

<span class="sd">    &gt;&gt;&gt; mutcaller_index0 = MutationCaller(mapper, targetindex=0)</span>
<span class="sd">    &gt;&gt;&gt; muts_index0 = mutcaller_index0.call(a, qvals)</span>
<span class="sd">    &gt;&gt;&gt; muts_index0.substitutions()</span>
<span class="sd">    [&#39;C3A&#39;, &#39;T5C&#39;, &#39;G11T&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_index0.deletions()</span>
<span class="sd">    [&#39;del7to8&#39;, &#39;del12to14&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_index0.insertions()</span>
<span class="sd">    [&#39;ins0len2&#39;, &#39;ins10len2&#39;]</span>

<span class="sd">    Use `target_clip` to ignore mutations near target termini:</span>

<span class="sd">    &gt;&gt;&gt; mutcaller_targetclip2 = MutationCaller(mapper, target_clip=2)</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip2 = mutcaller_targetclip2.call(a, qvals)</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip2.substitutions()</span>
<span class="sd">    [&#39;C4A&#39;, &#39;T6C&#39;, &#39;G12T&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip2.deletions()</span>
<span class="sd">    [&#39;del8to9&#39;, &#39;del13to15&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip2.insertions()</span>
<span class="sd">    [&#39;ins11len2&#39;]</span>
<span class="sd">    &gt;&gt;&gt; mutcaller_targetclip4 = MutationCaller(mapper, target_clip=4)</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip4 = mutcaller_targetclip4.call(a, qvals)</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip4.substitutions()</span>
<span class="sd">    [&#39;T6C&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip4.deletions()</span>
<span class="sd">    [&#39;del8to9&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_targetclip4.insertions()</span>
<span class="sd">    [&#39;ins11len2&#39;]</span>

<span class="sd">    Use `query_softclip` to ignore clipped regions in query:</span>

<span class="sd">    &gt;&gt;&gt; mutcaller_querysoftclip = MutationCaller(mapper, query_softclip=3)</span>
<span class="sd">    &gt;&gt;&gt; muts_querysoftclip = mutcaller_querysoftclip.call(a, qvals)</span>
<span class="sd">    &gt;&gt;&gt; muts_querysoftclip.substitutions()</span>
<span class="sd">    [&#39;C4A&#39;, &#39;T6C&#39;, &#39;G12T&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_querysoftclip.deletions()</span>
<span class="sd">    [&#39;del8to9&#39;, &#39;del13to15&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_querysoftclip.insertions()</span>
<span class="sd">    [&#39;ins11len2&#39;]</span>

<span class="sd">    Now use `transcriptconverter` to get mutations numbered in</span>
<span class="sd">    chromosome coordinates along with amino-acid substitutions.</span>
<span class="sd">    First, initialize a :class:`dms_tools2.seqnumbering.TranscriptConverter`:</span>

<span class="sd">    &gt;&gt;&gt; with tempfile.NamedTemporaryFile(mode=&#39;r+&#39;) as genbankfile:</span>
<span class="sd">    ...     _ = genbankfile.write(&#39;&#39;&#39;</span>
<span class="sd">    ... LOCUS       chromosome                17 bp    DNA              UNK 01-JAN-1980</span>
<span class="sd">    ... FEATURES             Location/Qualifiers</span>
<span class="sd">    ...      mRNA            3..17</span>
<span class="sd">    ...                      /label=&quot;target&quot;</span>
<span class="sd">    ...      CDS             3..14</span>
<span class="sd">    ...                      /label=&quot;prot&quot;</span>
<span class="sd">    ... ORIGIN</span>
<span class="sd">    ...         1 CAATGCATGG ATCGAAT</span>
<span class="sd">    ... //</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    ...     genbankfile.flush()</span>
<span class="sd">    ...     _ = genbankfile.seek(0)</span>
<span class="sd">    ...     transcriptconverter = dms_tools2.seqnumbering.TranscriptConverter(genbankfile)</span>

<span class="sd">    Now create a :class:`MutationCaller` that uses `transcriptconverter`:</span>

<span class="sd">    &gt;&gt;&gt; mutcaller_tc = MutationCaller(mapper, transcriptconverter=transcriptconverter)</span>

<span class="sd">    Use it to call the mutations in chromosome coordinates. Note that</span>
<span class="sd">    the amino-acid substitutions that result from a nucleotide point</span>
<span class="sd">    substitution are also indicated in the results:</span>

<span class="sd">    &gt;&gt;&gt; muts_tc = mutcaller_tc.call(a, qvals)</span>
<span class="sd">    &gt;&gt;&gt; muts_tc.substitutions()</span>
<span class="sd">    [&#39;chromosome-C6A_prot-His2Asn&#39;, &#39;chromosome-T8C&#39;, &#39;chromosome-G14T&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_tc.substitutions(returnval=&#39;site&#39;)</span>
<span class="sd">    [6, 8, 14]</span>
<span class="sd">    &gt;&gt;&gt; muts_tc.deletions()</span>
<span class="sd">    [&#39;chromosome-del10to11&#39;, &#39;chromosome-del15to17&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_tc.deletions(returnval=&#39;site&#39;)</span>
<span class="sd">    [10, 15]</span>
<span class="sd">    &gt;&gt;&gt; muts_tc.insertions()</span>
<span class="sd">    [&#39;chromosome-ins3len2&#39;, &#39;chromosome-ins13len2&#39;]</span>
<span class="sd">    &gt;&gt;&gt; muts_tc.insertions(returnval=&#39;site&#39;)</span>
<span class="sd">    [3, 13]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">transcriptconverter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">targetindex</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">target_clip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">query_softclip</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class docstring.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="n">mapper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span> <span class="o">=</span> <span class="n">transcriptconverter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">=</span> <span class="n">targetindex</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If using `transcriptconverter`, then &quot;</span>
                    <span class="s2">&quot;`targetindex` must be 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_clip</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">target_clip</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`target_clip` not int &gt;= 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_clip</span> <span class="o">=</span> <span class="n">target_clip</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query_softclip</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">query_softclip</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`query_softclip` not int &gt;= 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_softclip</span> <span class="o">=</span> <span class="n">query_softclip</span>


<div class="viewcode-block" id="MutationCaller.call"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.MutationCaller.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">qvals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call mutations in alignment.</span>

<span class="sd">        Args:</span>
<span class="sd">            `a` (:class:`Alignment`)</span>
<span class="sd">                Call mutations in this alignment.</span>
<span class="sd">            `qvals` (`None` or numpy array)</span>
<span class="sd">                Array of Q-values for the **entire** query used</span>
<span class="sd">                to build alignment, not just aligned region.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A :class:`Mutations` object holding the mutations.</span>
<span class="sd">            If you are **not** using `transcriptconverter`,</span>
<span class="sd">            mutations are named like this:</span>

<span class="sd">                - &quot;A60T&quot; for substitution (at site 60)</span>
<span class="sd">                - &quot;ins5len10&quot; for insertion (starts at 5, length 10)</span>
<span class="sd">                - &quot;del12to14&quot; for deletion (12, 13, and 14 deleted)</span>

<span class="sd">            where the number refers to the alignment target in</span>
<span class="sd">            `mapper`.</span>

<span class="sd">            If you are using `transcriptconverter`, then mutations are</span>
<span class="sd">            named like this:</span>

<span class="sd">                - &quot;fluNS-A61T_fluNS1-Asp12Val&quot; indicating</span>
<span class="sd">                  substitution at site 61 in the &quot;fluNS&quot; chromosome</span>
<span class="sd">                  causing amino-acid substitution Asp12Val in</span>
<span class="sd">                  the &quot;fluNS1&quot; CDS. If there is no amino-acid</span>
<span class="sd">                  substitution, the name will just be &quot;fluNS-A61T&quot;.</span>
<span class="sd">                - &quot;fluNS-ins4len10&quot; for insertion (again, now</span>
<span class="sd">                  in coordinates of the chromosome, which is &quot;fluNS&quot;.</span>
<span class="sd">                - &quot;fluNS-del11to13&quot; for deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_get_qval</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Q-value for site aligning to target `i`.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">qvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">iTargetToQuery</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">qvals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="n">substitution_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deletion_tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">insertion_tuples</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># deletions / insertions before alignment</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">r_st</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">istart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span>
            <span class="n">iend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">r_st</span>
            <span class="n">deletion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">istart</span><span class="p">,</span>
                    <span class="n">iend</span><span class="p">,</span>
                    <span class="s1">&#39;del</span><span class="si">{0}</span><span class="s1">to</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">),</span>
                    <span class="n">_get_qval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">r_st</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">q_st</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_softclip</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">i_qvals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_qvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">qvals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">q_st</span><span class="p">)]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span>
            <span class="n">ins_len</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">q_st</span>
            <span class="n">insertion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span>
                    <span class="s1">&#39;ins</span><span class="si">{0}</span><span class="s1">len</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">),</span> <span class="n">i_qvals</span><span class="p">))</span>

        <span class="c1"># mutations in alignment</span>
        <span class="n">itarget</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">r_st</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span>
        <span class="n">cigar</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">cigar_str</span>
        <span class="k">while</span> <span class="n">cigar</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">_CIGAR_GROUP_MATCH</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">itarget</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">==</span> <span class="mi">3</span>
                <span class="n">substitution_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">itarget</span><span class="p">,</span>
                        <span class="s1">&#39;</span><span class="si">{0}{1}{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                                <span class="n">itarget</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()),</span>
                        <span class="n">_get_qval</span><span class="p">(</span><span class="n">itarget</span><span class="p">)))</span>
                <span class="n">itarget</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">istart</span> <span class="o">=</span> <span class="n">itarget</span>
                <span class="n">iend</span> <span class="o">=</span> <span class="n">itarget</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">deletion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span>
                        <span class="s1">&#39;del</span><span class="si">{0}</span><span class="s1">to</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">),</span>
                        <span class="n">_get_qval</span><span class="p">(</span><span class="n">itarget</span> <span class="o">+</span> <span class="n">n</span><span class="p">)))</span>
                <span class="n">itarget</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">qvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">i_qvals</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">iTargetToQuery</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">itarget</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">i_qvals</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">i_qvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">qvals</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
                <span class="n">insertion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">itarget</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                        <span class="s1">&#39;ins</span><span class="si">{0}</span><span class="s1">len</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">itarget</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">i_qvals</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;~&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle intron operations&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;should never get here&quot;</span><span class="p">)</span>
            <span class="n">cigar</span> <span class="o">=</span> <span class="n">cigar</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">:</span> <span class="p">]</span>
        <span class="k">assert</span> <span class="n">cigar</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">itarget</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;itarget = </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">self.targetindex = </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;a.r_en = </span><span class="si">{2}</span><span class="se">\n</span><span class="s2">a = </span><span class="si">{3}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">itarget</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

        <span class="c1"># deletions / insertions after alignment</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">r_len</span><span class="p">:</span>
            <span class="n">istart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span>
            <span class="n">iend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span> <span class="n">r_len</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">deletion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                    <span class="n">istart</span><span class="p">,</span>
                    <span class="n">iend</span><span class="p">,</span>
                    <span class="s1">&#39;del</span><span class="si">{0}</span><span class="s1">to</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">),</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">q_en</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">q_len</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_softclip</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">q_len</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">q_en</span>
            <span class="k">if</span> <span class="n">qvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">i_qvals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_qvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">qvals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">q_en</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">q_len</span><span class="p">)]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span>
            <span class="n">insertion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39;ins</span><span class="si">{0}</span><span class="s1">len</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">i_qvals</span><span class="p">))</span>

        <span class="c1"># filter away mutations too near target termini</span>
        <span class="n">i_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_clip</span>
        <span class="n">i_last</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">r_len</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_clip</span>
        <span class="n">substitution_tuples</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">substitution_tuples</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i_first</span> <span class="ow">or</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">i_last</span><span class="p">)]</span>
        <span class="n">insertion_tuples</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">insertion_tuples</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i_first</span> <span class="ow">or</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">i_last</span><span class="p">)]</span>
        <span class="n">deletion_tuples</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">deletion_tuples</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i_first</span> <span class="ow">or</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">i_last</span><span class="p">)]</span>

        <span class="c1"># add homopolymer lengths for indels</span>
        <span class="k">def</span> <span class="nf">_hpLen</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">targetseq</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Homopolymer length.&quot;&quot;&quot;</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetindex</span>
            <span class="n">nt</span> <span class="o">=</span> <span class="n">targetseq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">mstart</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^</span><span class="si">{0}</span><span class="s1">+&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nt</span><span class="p">))</span>
            <span class="n">mend</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">+$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nt</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mstart</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">targetseq</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">mend</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">targetseq</span><span class="p">[</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">targetseq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">targetseqs</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>
        <span class="n">insertion_tuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">_hpLen</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">targetseq</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">insertion_tuples</span><span class="p">]</span>
        <span class="n">deletion_tuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">_hpLen</span><span class="p">(</span><span class="n">istart</span><span class="p">,</span> <span class="n">targetseq</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">deletion_tuples</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span><span class="o">.</span><span class="n">mRNA_chromosome</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>

            <span class="n">new_substitution_tuples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">substitution_tuples</span><span class="p">:</span>
                <span class="n">i_chrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span><span class="o">.</span><span class="n">i_mRNAtoChromosome</span><span class="p">(</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mRNAfragment</span><span class="o">=</span><span class="n">targetseq</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(?P&lt;wt_nt&gt;[</span><span class="si">{0}</span><span class="s1">])(?P&lt;site&gt;\d+)(?P&lt;mut_nt&gt;[</span><span class="si">{0}</span><span class="s1">])$&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">NTS</span><span class="p">)),</span> <span class="n">mut_str</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;can&#39;t match </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mut_str</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;site&#39;</span><span class="p">))</span>
                <span class="n">wt_nt</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;wt_nt&#39;</span><span class="p">)</span>
                <span class="n">mut_nt</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;mut_nt&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">wt_nt</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span><span class="o">.</span><span class="n">ntIdentity</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">i_chrom</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong wildtype in `transcriptconverter`&quot;</span><span class="p">)</span>
                <span class="n">aasubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span><span class="o">.</span><span class="n">aaSubstitutions</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">wt_nt</span><span class="p">,</span> <span class="n">i_chrom</span><span class="p">,</span> <span class="n">mut_nt</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">aasubs</span><span class="p">:</span>
                    <span class="n">aasubs</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">aasubs</span>
                <span class="n">new_substitution_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                        <span class="n">i_chrom</span><span class="p">,</span>
                        <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}{2}{3}{4}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">chrom</span><span class="p">,</span> <span class="n">wt_nt</span><span class="p">,</span> <span class="n">i_chrom</span><span class="p">,</span> <span class="n">mut_nt</span><span class="p">,</span> <span class="n">aasubs</span><span class="p">),</span>
                        <span class="n">q</span><span class="p">))</span>
            <span class="n">substitution_tuples</span> <span class="o">=</span> <span class="n">new_substitution_tuples</span>

            <span class="n">new_insertion_tuples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">hplen</span> <span class="ow">in</span> <span class="n">insertion_tuples</span><span class="p">:</span>
                <span class="n">i_chrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span><span class="o">.</span><span class="n">i_mRNAtoChromosome</span><span class="p">(</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mRNAfragment</span><span class="o">=</span><span class="n">targetseq</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^ins(?P&lt;i&gt;\d+)len(?P&lt;len&gt;\d+)$&#39;</span><span class="p">,</span>
                        <span class="n">mut_str</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;can&#39;t match </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mut_str</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">))</span>
                <span class="n">new_insertion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                        <span class="n">i_chrom</span><span class="p">,</span>
                        <span class="n">ins_len</span><span class="p">,</span>
                        <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-ins</span><span class="si">{1}</span><span class="s1">len</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">i_chrom</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;len&#39;</span><span class="p">)),</span>
                        <span class="n">q</span><span class="p">,</span>
                        <span class="n">hplen</span><span class="p">))</span>
            <span class="n">insertion_tuples</span> <span class="o">=</span> <span class="n">new_insertion_tuples</span>

            <span class="n">new_deletion_tuples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">mut_str</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">hplen</span> <span class="ow">in</span> <span class="n">deletion_tuples</span><span class="p">:</span>
                <span class="n">istart_chrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span><span class="o">.</span><span class="n">i_mRNAtoChromosome</span><span class="p">(</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">istart</span><span class="p">,</span> <span class="n">mRNAfragment</span><span class="o">=</span><span class="n">targetseq</span><span class="p">)</span>
                <span class="n">iend_chrom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transcriptconverter</span><span class="o">.</span><span class="n">i_mRNAtoChromosome</span><span class="p">(</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">mRNAfragment</span><span class="o">=</span><span class="n">targetseq</span><span class="p">)</span>
                <span class="n">new_deletion_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                        <span class="n">istart_chrom</span><span class="p">,</span>
                        <span class="n">iend_chrom</span><span class="p">,</span>
                        <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-del</span><span class="si">{1}</span><span class="s1">to</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">istart_chrom</span><span class="p">,</span> <span class="n">iend_chrom</span><span class="p">),</span>
                        <span class="n">q</span><span class="p">,</span>
                        <span class="n">hplen</span><span class="p">))</span>
            <span class="n">deletion_tuples</span> <span class="o">=</span> <span class="n">new_deletion_tuples</span>


        <span class="k">return</span> <span class="n">Mutations</span><span class="p">(</span><span class="n">substitution_tuples</span><span class="o">=</span><span class="n">substitution_tuples</span><span class="p">,</span>
                         <span class="n">insertion_tuples</span><span class="o">=</span><span class="n">insertion_tuples</span><span class="p">,</span>
                         <span class="n">deletion_tuples</span><span class="o">=</span><span class="n">deletion_tuples</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MutationConsensus"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.MutationConsensus">[docs]</a><span class="k">class</span> <span class="nc">MutationConsensus</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Takes consensus of several :class:`Mutations`.</span>

<span class="sd">    Designed for when you have called :class:`Mutations`</span>
<span class="sd">    for several sequences thought to represent the same template.</span>
<span class="sd">    The method make some use of statistical information in the</span>
<span class="sd">    accuracies computed from quality scores, but is heuristic.</span>
<span class="sd">    This is because it is designed for cases where causes other than</span>
<span class="sd">    simple sequencing error (e.g., mis-assigned sequences, true mix</span>
<span class="sd">    of templates, errors during library preparation) may be present.</span>

<span class="sd">    Initialize a :class:`MutationConsensus` object with arguments</span>
<span class="sd">    below, which become attributes of the object. Then call consensus</span>
<span class="sd">    mutations with :class:`MutationConsensus.callConsensus` method.</span>

<span class="sd">    Args:</span>
<span class="sd">        `n_mut` (int)</span>
<span class="sd">            At least this many sequences must have mutation to</span>
<span class="sd">            call it in consensus.</span>
<span class="sd">        `min_acc` (float)</span>
<span class="sd">            Completely ignore any mutations with accuracy lower</span>
<span class="sd">            than this. Should be a threshold that just gets rid</span>
<span class="sd">            of really low-accuracy ones. Is **not** applied to</span>
<span class="sd">            mutations with an accuracy of NaN (`math.nan`).</span>
<span class="sd">        `min_sub_frac` (float)</span>
<span class="sd">            More than this fraction of sequences must have</span>
<span class="sd">            substitution (point mutation) to call it as present.</span>
<span class="sd">        `min_indel_frac` (float)</span>
<span class="sd">            More than this fraction of sequences must have an</span>
<span class="sd">            indel to call it as present. By default this is more</span>
<span class="sd">            stringent than `min_sub_frac` because indel sequencing</span>
<span class="sd">            errors are more common and deletions can be enriched</span>
<span class="sd">            during PCR.</span>
<span class="sd">        `group_indel_frac` (float)</span>
<span class="sd">            If other overlap by &gt;= this fraction of their</span>
<span class="sd">            total net length with the most common indel,</span>
<span class="sd">            group them together as the most common indel.</span>
<span class="sd">            Designed to handle this case where alignment issues</span>
<span class="sd">            slightly change called boundaries of long indels.</span>
<span class="sd">        `homopolymer_calling` (dict)</span>
<span class="sd">            More stringent calling of **single-nucleotide**</span>
<span class="sd">            indels in hompolymers, which are defined as runs of</span>
<span class="sd">            &gt;= 3 consecutive nucleotides. Rationale</span>
<span class="sd">            is that main mode of PacBio sequencing errors is</span>
<span class="sd">            short indels in homopolymers. Can contain entries</span>
<span class="sd">            keyed by &quot;n_mut&quot; and &quot;min_indel_frac&quot;.</span>
<span class="sd">            Then for single-nucleotide indels in &gt;= 3 nt homopolymers,</span>
<span class="sd">            increases calling stringency to these new parameters.</span>
<span class="sd">            If no entry in dict, just uses main values set for</span>
<span class="sd">            other mutations, so supply empty dict if you want to</span>
<span class="sd">            no homopolymer correction.</span>

<span class="sd">    Mutations are called from the list of :class:`Mutations`</span>
<span class="sd">    passed to :class:`MutationConsensus.callConsensus` as follows:</span>

<span class="sd">      1. Ignore any mutations with accuracy less then `min_acc`,</span>
<span class="sd">         but do **not** eliminate mutations with accuracy that</span>
<span class="sd">         is `math.nan`.</span>

<span class="sd">      2. If there are less then `n_mut` :class:`Mutations` passed,</span>
<span class="sd">         and they have no mutations, call as wildtype.</span>

<span class="sd">      3. If there are less than `n_mut` :class:`Mutations`</span>
<span class="sd">         passed and some have mutations, call as ambiguous.</span>

<span class="sd">      4. If there are at least `n_mut` :class:`Mutations`</span>
<span class="sd">         passed but less than `n_mut` of them have a mutation,</span>
<span class="sd">         call as wildtype.</span>

<span class="sd">      5. If there are at least `n_mut` :class:`Mutations`</span>
<span class="sd">         that contain a specific mutation</span>
<span class="sd">         **and** the fraction of :class:`Mutations` that</span>
<span class="sd">         have this mutation is &gt;= `min_sub_frac` (for point</span>
<span class="sd">         mutations) or `min_indel_frac` (for indels), then call</span>
<span class="sd">         the sequence as having the mutation.</span>

<span class="sd">      6. Otherwise call as wildtype.</span>

<span class="sd">    Here is an example.</span>

<span class="sd">    First, define some :class:`Mutations`:</span>

<span class="sd">    &gt;&gt;&gt; m_wt = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[],</span>
<span class="sd">    ...         insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[])</span>
<span class="sd">    &gt;&gt;&gt; m_A1G_high_acc = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[(1, &#39;A1G&#39;, 30)],</span>
<span class="sd">    ...         insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[])</span>
<span class="sd">    &gt;&gt;&gt; m_A1G_low_acc = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[(1, &#39;A1G&#39;, 9)],</span>
<span class="sd">    ...         insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[])</span>

<span class="sd">    Initialize a :class:`MutationConsensus` with default args:</span>

<span class="sd">    &gt;&gt;&gt; mutcons = MutationConsensus()</span>

<span class="sd">    A single :class:`Mutations` with no mutation is called wildtype,</span>
<span class="sd">    and so returns an empty string:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_wt], &#39;substitutions&#39;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_wt], &#39;insertions&#39;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_wt], &#39;deletions&#39;)</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    Same for two with no mutations:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_wt, m_wt], &#39;substitutions&#39;)</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    A single :class:`Mutations` with mutations is called as ambiguous:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_high_acc], &#39;substitutions&#39;)</span>
<span class="sd">    &#39;unknown&#39;</span>

<span class="sd">    One with mutations and one without is called wildtype:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_high_acc, m_wt], &#39;substitutions&#39;)</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    Two high-quality mutation calls are give a consensus mutation:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_high_acc, m_A1G_high_acc], &#39;substitutions&#39;)</span>
<span class="sd">    &#39;A1G&#39;</span>

<span class="sd">    But it two low-quality mutation calls do not:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_low_acc, m_A1G_low_acc], &#39;substitutions&#39;)</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    Having two mutation calls and one wildtype call gives mutation:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_high_acc, m_A1G_high_acc, m_wt],</span>
<span class="sd">    ...         &#39;substitutions&#39;)</span>
<span class="sd">    &#39;A1G&#39;</span>

<span class="sd">    Unless the wildtype is in sufficient excess:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_high_acc] * 2 + [m_wt] * 8,</span>
<span class="sd">    ...         &#39;substitutions&#39;)</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    Example with two substitutions:</span>

<span class="sd">    &gt;&gt;&gt; m_A1G_T2A_high_acc = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[(1, &#39;A1G&#39;, 30), (2, &#39;T2A&#39;, 30)],</span>
<span class="sd">    ...         insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[])</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_T2A_high_acc, m_A1G_T2A_high_acc],</span>
<span class="sd">    ...         &#39;substitutions&#39;)</span>
<span class="sd">    &#39;A1G T2A&#39;</span>

<span class="sd">    Example where one sequence has two mutations (enough to be called)</span>
<span class="sd">    and the other only has one (not enough to be called):</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_T2A_high_acc, m_A1G_high_acc],</span>
<span class="sd">    ...         &#39;substitutions&#39;)</span>
<span class="sd">    &#39;A1G&#39;</span>

<span class="sd">    Use the `include_stats` option to get more detailed output:</span>

<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_A1G_T2A_high_acc, m_A1G_T2A_high_acc,</span>
<span class="sd">    ...         m_A1G_high_acc, m_wt], &#39;substitutions&#39;, include_stats=True)</span>
<span class="sd">    &#39;A1G_(3/4) T2A_(2/4)&#39;</span>

<span class="sd">    Group sufficiently overlapping indels:</span>

<span class="sd">    &gt;&gt;&gt; m_shortdel = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[],</span>
<span class="sd">    ...         insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[(8, 9, &#39;del8to9&#39;, math.nan, 1)])</span>
<span class="sd">    &gt;&gt;&gt; m_longdel = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[],</span>
<span class="sd">    ...         insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[(8, 18, &#39;del8to18&#39;, math.nan, 1)])</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_shortdel] * 2, &#39;deletions&#39;)</span>
<span class="sd">    &#39;del8to9&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_longdel] * 2, &#39;deletions&#39;)</span>
<span class="sd">    &#39;del8to18&#39;</span>
<span class="sd">    &gt;&gt;&gt; m_overlaplongdel = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[],</span>
<span class="sd">    ...         insertion_tuples=[],</span>
<span class="sd">    ...         deletion_tuples=[(9, 17, &#39;del9to17&#39;, math.nan, 1)])</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_longdel, m_shortdel], &#39;deletions&#39;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_wt, m_longdel] + [m_overlaplongdel] * 4,</span>
<span class="sd">    ...         &#39;deletions&#39;)</span>
<span class="sd">    &#39;del9to17&#39;</span>

<span class="sd">    Demonstrate `min_acc` filter:</span>

<span class="sd">    &gt;&gt;&gt; mutcons_no_min_acc = MutationConsensus(min_acc=0)</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_wt, m_A1G_low_acc] * 6, &#39;substitutions&#39;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons_no_min_acc.callConsensus([m_wt, m_A1G_low_acc] * 6, &#39;substitutions&#39;)</span>
<span class="sd">    &#39;A1G&#39;</span>

<span class="sd">    Demonstrate `homopolymer_calling`:</span>

<span class="sd">    &gt;&gt;&gt; m_homopolymer_indel = Mutations(</span>
<span class="sd">    ...         substitution_tuples=[],</span>
<span class="sd">    ...         insertion_tuples=[(13, 1, &#39;ins13len1&#39;, math.nan, 3)],</span>
<span class="sd">    ...         deletion_tuples=[(9, 10, &#39;del9to10&#39;, math.nan, 3),</span>
<span class="sd">    ...                          (5, 5, &#39;del5to5&#39;, math.nan, 3)])</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_homopolymer_indel] * 2, &#39;insertions&#39;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_homopolymer_indel] * 2, &#39;deletions&#39;)</span>
<span class="sd">    &#39;del9to10&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_homopolymer_indel] * 3, &#39;insertions&#39;)</span>
<span class="sd">    &#39;ins13len1&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_homopolymer_indel] * 3, &#39;deletions&#39;)</span>
<span class="sd">    &#39;del5to5 del9to10&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_homopolymer_indel] * 3 + [m_wt] * 4, &#39;deletions&#39;)</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; mutcons.callConsensus([m_homopolymer_indel] * 3 + [m_wt] * 2, &#39;deletions&#39;)</span>
<span class="sd">    &#39;del5to5 del9to10&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n_mut</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_acc</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span> <span class="n">min_sub_frac</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
            <span class="n">min_indel_frac</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">group_indel_frac</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
            <span class="n">homopolymer_calling</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;n_mut&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">},</span>
            <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class doc string.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_mut</span> <span class="o">=</span> <span class="n">n_mut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_acc</span> <span class="o">=</span> <span class="n">min_acc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sub_frac</span> <span class="o">=</span> <span class="n">min_sub_frac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_indel_frac</span> <span class="o">=</span> <span class="n">min_indel_frac</span>

        <span class="n">homopolymer_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;n_mut&#39;</span><span class="p">,</span> <span class="s1">&#39;min_indel_frac&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">homopolymer_calling</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="n">homopolymer_params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entries in `homopolymer_calling`&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">homopolymer_params</span><span class="p">:</span>
            <span class="n">val_all</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">p_homopolymer</span> <span class="o">=</span> <span class="s1">&#39;homopolymer_&#39;</span> <span class="o">+</span> <span class="n">p</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">homopolymer_calling</span><span class="p">:</span>
                <span class="n">val_homopolymer</span> <span class="o">=</span> <span class="n">homopolymer_calling</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">val_homopolymer</span> <span class="o">&lt;</span> <span class="n">val_all</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`homopolymer_calling` sets less &quot;</span>
                            <span class="s2">&quot;stringent value for </span><span class="si">{0}</span><span class="s2">, which makes no &quot;</span>
                            <span class="s2">&quot;sense.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_homopolymer</span><span class="p">,</span> <span class="n">val_homopolymer</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_homopolymer</span><span class="p">,</span> <span class="n">val_all</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">group_indel_frac</span> <span class="o">=</span> <span class="n">group_indel_frac</span>


<div class="viewcode-block" id="MutationConsensus.callConsensus"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.MutationConsensus.callConsensus">[docs]</a>    <span class="k">def</span> <span class="nf">callConsensus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mutationlist</span><span class="p">,</span> <span class="n">mutation_type</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">include_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls consensus from :class:`Mutations`.</span>

<span class="sd">        The calling is done using the criteria described in the</span>
<span class="sd">        main docs for :class:`MutationConsensus`.</span>

<span class="sd">        Args:</span>
<span class="sd">            `mutationlist` (list)</span>
<span class="sd">                List of one or more :class:`Mutations` from</span>
<span class="sd">                which we call consensus.</span>
<span class="sd">            `mutation_type` (str)</span>
<span class="sd">                Type of mutation to call. Should be one of</span>
<span class="sd">                &#39;substitutions&#39;, &#39;insertions&#39;, or &#39;deletions&#39;.</span>
<span class="sd">            `include_stats` (bool)</span>
<span class="sd">                Include statistics on number of CCSs that have</span>
<span class="sd">                mutation for each called mutation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A str giving the result. If consensus of mutations</span>
<span class="sd">            cannot be called, returns the string &quot;unknown&quot;.</span>
<span class="sd">            Otherwise returns empty string if no consensus mutations,</span>
<span class="sd">            or a string giving the mutations separated by spaces</span>
<span class="sd">            the same way they are returned by the methods of</span>
<span class="sd">            :class:`Mutations`. Mutations are sorted first by</span>
<span class="sd">            number of times observed, and then alphabetically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nseqs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutationlist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nseqs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;empty `mutationlist`&quot;</span><span class="p">)</span>

        <span class="c1"># function to get mutations of this type</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;insertions&#39;</span><span class="p">:</span><span class="n">Mutations</span><span class="o">.</span><span class="n">insertions</span><span class="p">,</span>
                    <span class="s1">&#39;substitutions&#39;</span><span class="p">:</span><span class="n">Mutations</span><span class="o">.</span><span class="n">substitutions</span><span class="p">,</span>
                    <span class="s1">&#39;deletions&#39;</span><span class="p">:</span><span class="n">Mutations</span><span class="o">.</span><span class="n">deletions</span><span class="p">}[</span><span class="n">mutation_type</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid `mutation_type` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mutation_type</span><span class="p">))</span>

        <span class="c1"># mutations</span>
        <span class="n">muts</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">min_acc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acc</span><span class="p">,</span> <span class="n">min_acc_filter_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mutationlist</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">muts</span><span class="p">)</span> <span class="o">==</span> <span class="n">nseqs</span>
        <span class="n">flatmuts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span> <span class="k">for</span> <span class="n">ml</span> <span class="ow">in</span> <span class="n">muts</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ml</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flatmuts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span> <span class="c1"># all sequences are wildtype</span>

        <span class="k">if</span> <span class="n">nseqs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mut</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;unknown&#39;</span> <span class="c1"># not enough sequences to call mutations</span>

        <span class="c1"># is mutation a short indel in homopolymer?</span>
        <span class="n">homopolymer_indel</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mutation_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;insertions&#39;</span><span class="p">,</span> <span class="s1">&#39;deletions&#39;</span><span class="p">}:</span>

            <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">returnval</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">min_acc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acc</span><span class="p">,</span>
                    <span class="n">min_acc_filter_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mutationlist</span><span class="p">]</span>
            <span class="n">flatlengths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">lengths</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">flatlengths</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flatmuts</span><span class="p">)</span>
            <span class="n">homopolymerlengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">returnval</span><span class="o">=</span><span class="s1">&#39;homopolymer_length&#39;</span><span class="p">,</span>
                    <span class="n">min_acc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acc</span><span class="p">,</span>
                    <span class="n">min_acc_filter_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mutationlist</span><span class="p">]</span>
            <span class="n">flathomopolymerlengths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span>
                    <span class="n">homopolymerlengths</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">flathomopolymerlengths</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flatmuts</span><span class="p">)</span>
            <span class="n">starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">returnval</span><span class="o">=</span><span class="s1">&#39;site&#39;</span><span class="p">,</span> <span class="n">min_acc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_acc</span><span class="p">,</span>
                    <span class="n">min_acc_filter_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mutationlist</span><span class="p">]</span>
            <span class="n">flatstarts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">starts</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">])</span>

            <span class="c1"># get indels in hompolymers of length &gt;= 3</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">flatmuts</span><span class="p">[(</span><span class="n">flatlengths</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">flathomopolymerlengths</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)]):</span>
                <span class="n">homopolymer_indel</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># group sufficiently overlapping indels</span>
            <span class="n">indelcounts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">flatmuts</span><span class="p">)</span>
            <span class="n">max_n</span> <span class="o">=</span> <span class="n">indelcounts</span><span class="o">.</span><span class="n">most_common</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">top_indels</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">indelcounts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">max_n</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top_indels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">top_indel</span> <span class="o">=</span> <span class="n">top_indels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># several top indels, take longest</span>
                <span class="n">top_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">flatlengths</span><span class="p">[</span><span class="n">flatmuts</span> <span class="o">==</span> <span class="n">top_indel</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span>
                        <span class="n">top_indel</span> <span class="ow">in</span> <span class="n">top_indels</span><span class="p">]</span>
                <span class="n">top_indel</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">top_lengths</span><span class="p">,</span> <span class="n">top_indels</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">overlapping_indels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">top_length</span> <span class="o">=</span> <span class="n">flatlengths</span><span class="p">[</span><span class="n">flatmuts</span> <span class="o">==</span> <span class="n">top_indel</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">top_start</span> <span class="o">=</span> <span class="n">flatstarts</span><span class="p">[</span><span class="n">flatmuts</span> <span class="o">==</span> <span class="n">top_indel</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">flatmuts</span><span class="p">):</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">flatlengths</span><span class="p">[</span><span class="n">flatmuts</span> <span class="o">==</span> <span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">flatstarts</span><span class="p">[</span><span class="n">flatmuts</span> <span class="o">==</span> <span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tot_len</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">top_start</span> <span class="o">+</span> <span class="n">top_length</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span>
                        <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">top_start</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
                <span class="n">overlap_len</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">top_start</span> <span class="o">+</span> <span class="n">top_length</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span>
                        <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">top_start</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">overlap_len</span> <span class="o">/</span> <span class="n">tot_len</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_indel_frac</span><span class="p">:</span>
                    <span class="n">overlapping_indels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">flatmuts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">top_indel</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">overlapping_indels</span>
                    <span class="k">else</span> <span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">flatmuts</span><span class="p">])</span>

        <span class="c1"># get counts of all mutations with adequate counts</span>
        <span class="n">mutcounts</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="p">:</span><span class="n">n</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">flatmuts</span><span class="p">)</span>
                <span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">homopolymer_indel</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mut</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">homopolymer_n_mut</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mutcounts</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span> <span class="c1"># no mutations with enough counts, call wildtype</span>

        <span class="n">mutlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">mutation_type</span> <span class="o">==</span> <span class="s1">&#39;substitutions&#39;</span><span class="p">:</span>
            <span class="n">min_mut_frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sub_frac</span>
            <span class="n">homopolymer_min_mut_frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_sub_frac</span>
        <span class="k">elif</span> <span class="n">mutation_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;insertions&#39;</span><span class="p">,</span> <span class="s1">&#39;deletions&#39;</span><span class="p">}:</span>
            <span class="n">min_mut_frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_indel_frac</span>
            <span class="n">homopolymer_min_mut_frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">homopolymer_min_indel_frac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid `mutation_type` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mutation_type</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">mutcounts</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tup</span><span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nseqs</span>
            <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">homopolymer_indel</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">min_mut_frac</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">homopolymer_min_mut_frac</span><span class="p">):</span>
                <span class="n">mstring</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mstring</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># consider wildtype</span>
            <span class="k">if</span> <span class="n">mstring</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">include_stats</span><span class="p">:</span>
                    <span class="n">mstring</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_(</span><span class="si">{1}</span><span class="s1">/</span><span class="si">{2}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mstring</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nseqs</span><span class="p">)</span>
                <span class="n">mutlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mstring</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mutlist</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Mapper"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.Mapper">[docs]</a><span class="k">class</span> <span class="nc">Mapper</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class to run ``minimap2`` and get results.</span>

<span class="sd">    Args:</span>
<span class="sd">        `targetfile` (str)</span>
<span class="sd">            FASTA file with target (reference) to which we align</span>
<span class="sd">            reads.</span>
<span class="sd">        `options` (list)</span>
<span class="sd">            Command line options to ``minimap2``. For</span>
<span class="sd">            recommended options, for different situations, see:</span>

<span class="sd">                - :data:`OPTIONS_CODON_DMS`</span>

<span class="sd">                - :data:`OPTIONS_VIRUS_W_DEL`</span>

<span class="sd">        `prog` (str or `None`)</span>
<span class="sd">            Path to ``minimap2`` executable. Class is only</span>
<span class="sd">            tested against version &gt;=2.11 but may work with</span>
<span class="sd">            other versions too.</span>
<span class="sd">        `target_isoforms` (dict)</span>
<span class="sd">            Sometimes targets might be be isoforms of each</span>
<span class="sd">            other. You can specify that with this dict, which</span>
<span class="sd">            is keyed by target names and has values that are sets</span>
<span class="sd">            of other targets. If targets `M1` and `M2` are isoforms,</span>
<span class="sd">            set `target_isoforms={&#39;M1&#39;:[&#39;M2&#39;], &#39;M2&#39;:[&#39;M1&#39;]}`.</span>
<span class="sd">            This argument is just used to set the `target_isoforms`</span>
<span class="sd">            attribute, but isn&#39;t used during alignment.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        `targetfile` (str)</span>
<span class="sd">            Target (reference) file set at initialization.</span>
<span class="sd">        `targetseqs` (OrderedDict)</span>
<span class="sd">            Sequences in `targetfile`. Keys are sequence</span>
<span class="sd">            names, values are sequences as strings. In</span>
<span class="sd">            same order as listing in `targetfile`.</span>
<span class="sd">        `prog` (str)</span>
<span class="sd">            Path to ``minimap2`` set at initialization.</span>
<span class="sd">        `options` (list)</span>
<span class="sd">            Options to ``minimap2`` set at initialization.</span>
<span class="sd">        `version` (str)</span>
<span class="sd">            Version of ``minimap2``.</span>
<span class="sd">        `target_isoforms` (dict)</span>
<span class="sd">            Isoforms for each target. This is the value set</span>
<span class="sd">            by `target_isoforms` at initialization plus</span>
<span class="sd">            ensuring that each target is listed as an isoform</span>
<span class="sd">            of itself.</span>

<span class="sd">    Here is an example where we align a few reads to two target</span>
<span class="sd">    sequences.</span>

<span class="sd">    First, we generate a few target sequences:</span>

<span class="sd">    &gt;&gt;&gt; targetlen = 200</span>
<span class="sd">    &gt;&gt;&gt; random.seed(1)</span>
<span class="sd">    &gt;&gt;&gt; targets = collections.OrderedDict()</span>
<span class="sd">    &gt;&gt;&gt; for i in [1, 2]:</span>
<span class="sd">    ...     targets[&#39;target{0}&#39;.format(i)] = &#39;&#39;.join(random.choice(NTS)</span>
<span class="sd">    ...             for _ in range(targetlen))</span>

<span class="sd">    Now we generate some queries. One is a random sequence that should not</span>
<span class="sd">    align, and the other two are substrings of the targets into which we</span>
<span class="sd">    have introduced a single mutation or indel. The names of the queries</span>
<span class="sd">    give their target, start in query, end in query, cigar string:</span>

<span class="sd">    &gt;&gt;&gt; queries = {&#39;randseq&#39;:&#39;&#39;.join(random.choice(NTS) for _ in range(180))}</span>
<span class="sd">    &gt;&gt;&gt; for qstart, qend, mut in [(0, 183, &#39;mut53&#39;), (36, 194, &#39;del140&#39;)]:</span>
<span class="sd">    ...     target = random.choice(list(targets.keys()))</span>
<span class="sd">    ...     qseq = targets[target][qstart : qend]</span>
<span class="sd">    ...     mutsite = int(mut[3 : ])</span>
<span class="sd">    ...     if &#39;mut&#39; in mut:</span>
<span class="sd">    ...         wt = qseq[mutsite]</span>
<span class="sd">    ...         mut = random.choice([nt for nt in NTS if nt != wt])</span>
<span class="sd">    ...         cigar = (&#39;=&#39; + qseq[ : mutsite] + &#39;*&#39; + wt.lower() +</span>
<span class="sd">    ...                  mut.lower() + &#39;=&#39; + qseq[mutsite + 1 : ])</span>
<span class="sd">    ...         qseq = qseq[ : mutsite] + mut + qseq[mutsite + 1 : ]</span>
<span class="sd">    ...     elif &#39;del&#39; in mut:</span>
<span class="sd">    ...         cigar = (&#39;=&#39; + qseq[ : mutsite] + &#39;-&#39; +</span>
<span class="sd">    ...                  qseq[mutsite].lower() + &#39;=&#39; + qseq[mutsite + 1 : ])</span>
<span class="sd">    ...         qseq = qseq[ : mutsite] + qseq[mutsite + 1 : ]</span>
<span class="sd">    ...     queryname = &#39;_&#39;.join(map(str, [target, qstart, qend, cigar]))</span>
<span class="sd">    ...     queries[queryname] = qseq</span>


<span class="sd">    Now map the queries to the targets:</span>

<span class="sd">    &gt;&gt;&gt; TempFile = functools.partial(tempfile.NamedTemporaryFile, mode=&#39;w&#39;)</span>
<span class="sd">    &gt;&gt;&gt; with TempFile() as targetfile, TempFile() as queryfile:</span>
<span class="sd">    ...     _ = targetfile.write(&#39;\\n&#39;.join(&#39;&gt;{0}\\n{1}&#39;.format(*tup)</span>
<span class="sd">    ...                          for tup in targets.items()))</span>
<span class="sd">    ...     targetfile.flush()</span>
<span class="sd">    ...     _ = queryfile.write(&#39;\\n&#39;.join(&#39;&gt;{0}\\n{1}&#39;.format(*tup)</span>
<span class="sd">    ...                         for tup in queries.items()))</span>
<span class="sd">    ...     queryfile.flush()</span>
<span class="sd">    ...     mapper = Mapper(targetfile.name, OPTIONS_CODON_DMS)</span>
<span class="sd">    ...     mapper2 = Mapper(targetfile.name, OPTIONS_CODON_DMS,</span>
<span class="sd">    ...             target_isoforms={&#39;target1&#39;:{&#39;target2&#39;},</span>
<span class="sd">    ...                              &#39;target2&#39;:{&#39;target1&#39;}})</span>
<span class="sd">    ...     alignments = mapper.map(queryfile.name)</span>
<span class="sd">    &gt;&gt;&gt; mapper.targetseqs == targets</span>
<span class="sd">    True</span>

<span class="sd">    Now make sure we find the expected alignments:</span>

<span class="sd">    &gt;&gt;&gt; set(alignments.keys()) == set(q for q in queries if q != &#39;randseq&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; matched = []</span>
<span class="sd">    &gt;&gt;&gt; for (query, a) in alignments.items():</span>
<span class="sd">    ...     expected = query.split(&#39;_&#39;)</span>
<span class="sd">    ...     matched.append(a.target == expected[0])</span>
<span class="sd">    ...     matched.append([a.r_st, a.r_en] == list(map(int, expected[1 : 3])))</span>
<span class="sd">    ...     matched.append([a.q_st, a.q_en] == [0, len(queries[query])])</span>
<span class="sd">    ...     matched.append(a.cigar_str == expected[3])</span>
<span class="sd">    ...     matched.append(a.strand == 1)</span>
<span class="sd">    &gt;&gt;&gt; all(matched)</span>
<span class="sd">    True</span>

<span class="sd">    Test out the `target_isoform` argument:</span>

<span class="sd">    &gt;&gt;&gt; mapper.target_isoforms == {&#39;target1&#39;:{&#39;target1&#39;}, &#39;target2&#39;:{&#39;target2&#39;}}</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; mapper2.target_isoforms == {&#39;target1&#39;:{&#39;target1&#39;, &#39;target2&#39;},</span>
<span class="sd">    ...         &#39;target2&#39;:{&#39;target1&#39;, &#39;target2&#39;}}</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetfile</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">prog</span><span class="o">=</span><span class="s1">&#39;minimap2&#39;</span><span class="p">,</span>
            <span class="n">target_isoforms</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;See main :class:`Mapper` doc string.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># use default ``minimap2`` installed as package data</span>
            <span class="n">prog</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span>
                                <span class="s1">&#39;minimap2_prog&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">version</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="n">prog</span><span class="p">,</span> <span class="s1">&#39;--version&#39;</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t execute `prog` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prog</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="n">min_version</span> <span class="o">=</span> <span class="n">packaging</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2.11&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">packaging</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_version</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have `minimap2` version </span><span class="si">{0}</span><span class="s2">, but &quot;</span>
                    <span class="s2">&quot;need at least </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">,</span> <span class="n">min_version</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prog</span> <span class="o">=</span> <span class="n">prog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">targetfile</span><span class="p">),</span> \
                <span class="s2">&quot;no `targetfile` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">targetfile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetfile</span> <span class="o">=</span> <span class="n">targetfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetseqs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">seq</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">Bio</span><span class="o">.</span><span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetfile</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)])</span>

        <span class="n">targetnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetseqs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">in_target_isoforms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">target_isoforms</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">t</span> <span class="k">for</span> <span class="n">tl</span> <span class="ow">in</span> <span class="n">target_isoforms</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tl</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">in_target_isoforms</span> <span class="o">-</span> <span class="n">targetnames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`target_isoforms` contains following &quot;</span>
                             <span class="s2">&quot;targets not in `targetfile`: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                             <span class="n">in_target_isoforms</span> <span class="o">-</span> <span class="n">targetnames</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_isoforms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targetnames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_isoforms</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">target_isoforms</span><span class="p">:</span>
                <span class="n">addtl_targets</span> <span class="o">=</span> <span class="n">target_isoforms</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">addtl_targets</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">addtl_targets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">addtl_targets</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_isoforms</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">addtl_targets</span><span class="p">)</span>


<div class="viewcode-block" id="Mapper.map"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.Mapper.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queryfile</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">introns_to_gaps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shift_indels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_alignments</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map query sequences to target.</span>

<span class="sd">        Aligns query sequences to targets. Adds ``--c --cs=long``</span>
<span class="sd">        arguments to `options` to get a long CIGAR string, and</span>
<span class="sd">        returns results as a dictionary, and optionally writes them</span>
<span class="sd">        to a PAF file.</span>

<span class="sd">        This is **not** a memory-efficient implementation as</span>
<span class="sd">        a lot is read into memory. So if you have very large</span>
<span class="sd">        queries or targets, that may pose a problem.</span>

<span class="sd">        Args:</span>
<span class="sd">            `queryfile` (str)</span>
<span class="sd">                FASTA file with query sequences to align.</span>
<span class="sd">                Headers should be unique.</span>
<span class="sd">            `outfile` (`None` or str)</span>
<span class="sd">                Name of output file containing alignment</span>
<span class="sd">                results in PAF format if a str is provided.</span>
<span class="sd">                Provide `None` if you don&#39;t want to create</span>
<span class="sd">                a permanent alignment file.</span>
<span class="sd">            `introns_to_gaps` (bool)</span>
<span class="sd">                If there are introns in the alignment CIGARs, convert</span>
<span class="sd">                to gaps by running through :meth:`intronsToGaps`.</span>
<span class="sd">            `shift_indels` (bool)</span>
<span class="sd">                Pass alignments through :meth:`shiftIndels`.</span>
<span class="sd">                Only applies to alignments returned in dict,</span>
<span class="sd">                does not affect any results in `outfile`.</span>
<span class="sd">            `check_alignments` (bool)</span>
<span class="sd">                Run all alignments through :meth:`checkAlignment`</span>
<span class="sd">                before returning, and raise error if any are invalid.</span>
<span class="sd">                This is a good debugging check, but costs time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dict where keys are the name of each query in</span>
<span class="sd">            `queryfile` for which there is an alignment (there</span>
<span class="sd">            are no keys for queries that do not align). If there</span>
<span class="sd">            is a single alignment for a query, the value is that</span>
<span class="sd">            :class:`Alignment` object. There can be multiple primary</span>
<span class="sd">            alignments (`see here &lt;https://github.com/lh3/minimap2/issues/113&gt;`_).</span>
<span class="sd">            If there are multiple alignments, the value is the</span>
<span class="sd">            :class:`Alignment` with the highest score, and the remaining</span>
<span class="sd">            alignments are listed in the :class:`Alignment.additional`</span>
<span class="sd">            attribute of that &quot;best&quot; alignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">queryfile</span><span class="p">),</span> <span class="s2">&quot;no `queryfile` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">queryfile</span><span class="p">)</span>

        <span class="k">assert</span> <span class="s1">&#39;-a&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> \
                <span class="s2">&quot;output should be PAF format, not SAM&quot;</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;--cs=long&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fout</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span>
        <span class="n">stderr</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prog</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">targetfile</span><span class="p">,</span> <span class="n">queryfile</span><span class="p">],</span>
                    <span class="n">stdout</span><span class="o">=</span><span class="n">fout</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">stderr</span><span class="p">)</span>
            <span class="n">fout</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dlist</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">query</span><span class="p">,</span> <span class="n">alignment</span> <span class="ow">in</span> <span class="n">parsePAF</span><span class="p">(</span><span class="n">fout</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">targetseqs</span><span class="p">,</span> <span class="n">introns_to_gaps</span><span class="p">):</span>
                <span class="n">dlist</span><span class="p">[</span><span class="n">query</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">stderr</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stderr</span><span class="o">.</span><span class="n">read</span><span class="p">()))</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">fout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">stderr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dlist</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dlist</span><span class="p">[</span><span class="n">query</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">query</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlist</span><span class="p">[</span><span class="n">query</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dlist</span><span class="p">[</span><span class="n">query</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="n">sorted_alignments</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                        <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">score</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dlist</span><span class="p">[</span><span class="n">query</span><span class="p">]],</span>
                        <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
                <span class="n">d</span><span class="p">[</span><span class="n">query</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_alignments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span>
                        <span class="n">additional</span><span class="o">=</span><span class="n">sorted_alignments</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">])</span>
            <span class="k">del</span> <span class="n">dlist</span><span class="p">[</span><span class="n">query</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">shift_indels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">new_cigar_str</span> <span class="o">=</span> <span class="n">shiftIndels</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">query</span><span class="p">]</span><span class="o">.</span><span class="n">cigar_str</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_cigar_str</span> <span class="o">!=</span> <span class="n">d</span><span class="p">[</span><span class="n">query</span><span class="p">]</span><span class="o">.</span><span class="n">cigar_str</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">query</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">query</span><span class="p">]</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">cigar_str</span><span class="o">=</span><span class="n">new_cigar_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_alignments</span><span class="p">:</span>
            <span class="n">queryseqs</span> <span class="o">=</span> <span class="p">{</span><span class="n">seq</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span>
                         <span class="n">Bio</span><span class="o">.</span><span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">queryfile</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">query</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">checkAlignment</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetseqs</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">],</span>
                        <span class="n">queryseqs</span><span class="p">[</span><span class="n">query</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid alignment for </span><span class="si">{0}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;alignment = </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">target = </span><span class="si">{2}</span><span class="se">\n</span><span class="s2">query = </span><span class="si">{3}</span><span class="s2">&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetseqs</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">],</span>
                            <span class="n">queryseqs</span><span class="p">[</span><span class="n">query</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">d</span></div></div>


<div class="viewcode-block" id="TargetVariants"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.TargetVariants">[docs]</a><span class="k">class</span> <span class="nc">TargetVariants</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;After alignment, assign to one of several target variants.</span>

<span class="sd">    Useful if you aligned against one set of targets, but</span>
<span class="sd">    in reality the queries could align to several different</span>
<span class="sd">    **point mutant** variants of that target. Use this</span>
<span class="sd">    class to take the alignments and see if they instead exactly</span>
<span class="sd">    match a variant of the target.</span>

<span class="sd">    Initialize to specify the target variants, then classify</span>
<span class="sd">    using :class:`TargetVariants.call`.</span>

<span class="sd">    Args:</span>
<span class="sd">        `variantfiles` (dict)</span>
<span class="sd">            Specifies FASTA files giving the target variants.</span>
<span class="sd">            Each file must have the same target names as in</span>
<span class="sd">            `mapper.targetfile`. These are the variants to</span>
<span class="sd">            which we compare the queries, and they must be</span>
<span class="sd">            point mutants (same length) as the targets for</span>
<span class="sd">            `mapper`. Currently only works when there are</span>
<span class="sd">            two sets of variants.</span>
<span class="sd">        `mapper` (:class:`Mapper`)</span>
<span class="sd">            The mapper used to make the alignments. Used to check</span>
<span class="sd">            that the sequences specified in `variantfiles` are</span>
<span class="sd">            proper point mutant variants of the alignment targets.</span>
<span class="sd">        `variantsites_min_acc` (float or `None`)</span>
<span class="sd">            Minimum required accuracy (computed from Q-values)</span>
<span class="sd">            required for calling by :class:`TargetVariants.call`.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        `variantfiles` (dict)</span>
<span class="sd">            See above.</span>
<span class="sd">        `mapper` (:class:`Mapper`)</span>
<span class="sd">            See above.</span>
<span class="sd">        `variantsites_min_acc` (float or `None`)</span>
<span class="sd">            See above.</span>
<span class="sd">        `variantnames` (list)</span>
<span class="sd">            Alphabeticized list of the variant names that key</span>
<span class="sd">            `variantfiles`.</span>
<span class="sd">        `targetnames` (list)</span>
<span class="sd">            Alphabeticized list of the target names.</span>
<span class="sd">        `variantseqs` (dict)</span>
<span class="sd">            The actual sequences in `variantfiles`. Keyed</span>
<span class="sd">            by each variant in `variantnames`, then keyed</span>
<span class="sd">            by each name in `targetnames`, and values</span>
<span class="sd">            are the sequences for that variant of that target.</span>
<span class="sd">        `variablesites` (dict)</span>
<span class="sd">            Keyed by target names, each value is a list of</span>
<span class="sd">            all sites that differ between target variants,</span>
<span class="sd">            sorted and in 0, 1, ... indexing.</span>
<span class="sd">        `sitevariants` (dict)</span>
<span class="sd">            `sitevariants[target][variant]` is a list that gives</span>
<span class="sd">            the identity of  `variant` for target ` at each site</span>
<span class="sd">            in `variablesites[target]`.</span>

<span class="sd">    Here is a short example.</span>

<span class="sd">    First, create two target seqs, and two variants that each</span>
<span class="sd">    differ at two positions:</span>

<span class="sd">    &gt;&gt;&gt; target1_wt  = &#39;ATGCATGAA&#39;</span>
<span class="sd">    &gt;&gt;&gt; target1_var = &#39;ATCCATGTA&#39;</span>
<span class="sd">    &gt;&gt;&gt; target2_wt  = &#39;GATACCCGG&#39;</span>
<span class="sd">    &gt;&gt;&gt; target2_var = &#39;GCTACCCCG&#39;</span>

<span class="sd">    Now write these to two targetfiles, initialize :class:`Mapper`</span>
<span class="sd">    with the wildtype target sets, initialize :class:`TargetVariants`</span>
<span class="sd">    with wildtype and variant target sets:</span>

<span class="sd">    &gt;&gt;&gt; TempFile = functools.partial(tempfile.NamedTemporaryFile, mode=&#39;w&#39;)</span>
<span class="sd">    &gt;&gt;&gt; with TempFile() as wtfile, TempFile() as varfile:</span>
<span class="sd">    ...     _ = wtfile.write(&#39;&gt;target1\\n{0}\\n&gt;target2\\n{1}&#39;.format(</span>
<span class="sd">    ...                      target1_wt, target2_wt))</span>
<span class="sd">    ...     wtfile.flush()</span>
<span class="sd">    ...     _ = varfile.write(&#39;&gt;target1\\n{0}\\n&gt;target2\\n{1}&#39;.format(</span>
<span class="sd">    ...                       target1_var, target2_var))</span>
<span class="sd">    ...     varfile.flush()</span>
<span class="sd">    ...     mapper = Mapper(wtfile.name, OPTIONS_CODON_DMS)</span>
<span class="sd">    ...     targetvars = TargetVariants(</span>
<span class="sd">    ...             {&#39;wildtype&#39;:wtfile.name, &#39;variant&#39;:varfile.name},</span>
<span class="sd">    ...             mapper, variantsites_min_acc=0.99)</span>
<span class="sd">    &gt;&gt;&gt; targetvars.variantnames</span>
<span class="sd">    [&#39;variant&#39;, &#39;wildtype&#39;]</span>
<span class="sd">    &gt;&gt;&gt; targetvars.targetnames</span>
<span class="sd">    [&#39;target1&#39;, &#39;target2&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted(targetvars.variablesites.items())</span>
<span class="sd">    [(&#39;target1&#39;, [2, 7]), (&#39;target2&#39;, [1, 7])]</span>
<span class="sd">    &gt;&gt;&gt; targetvars.sitevariants == {</span>
<span class="sd">    ...         &#39;target1&#39;:{&#39;wildtype&#39;:[&#39;G&#39;, &#39;A&#39;], &#39;variant&#39;:[&#39;C&#39;, &#39;T&#39;]},</span>
<span class="sd">    ...         &#39;target2&#39;:{&#39;wildtype&#39;:[&#39;A&#39;, &#39;G&#39;], &#39;variant&#39;:[&#39;C&#39;, &#39;C&#39;]}}</span>
<span class="sd">    True</span>

<span class="sd">    Now test on some alignments. First, one that matches the</span>
<span class="sd">    wildtype of target2:</span>

<span class="sd">    &gt;&gt;&gt; a_wildtype = Alignment(q_st=0, q_en=8, q_len=8, strand=1,</span>
<span class="sd">    ...         r_st=1, r_en=9, r_len=9, score=16, target=&#39;target2&#39;,</span>
<span class="sd">    ...         additional=[], cigar_str=&#39;=ATACCCGG&#39;)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_wildtype)</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;wildtype&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_wildtype == a_new</span>
<span class="sd">    True</span>

<span class="sd">    Now one that matches the variant of target2:</span>

<span class="sd">    &gt;&gt;&gt; a_variant = a_wildtype._replace(cigar_str=&#39;*ac=TACCC*gc=G&#39;)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_variant)</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;variant&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_variant == a_new</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; a_new.cigar_str</span>
<span class="sd">    &#39;=CTACCCCG&#39;</span>

<span class="sd">    Now one that matches the variant of target2, but also has another</span>
<span class="sd">    mutation:</span>

<span class="sd">    &gt;&gt;&gt; a_variant = a_wildtype._replace(cigar_str=&#39;*ac=TA*ca=CC*gc=G&#39;)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_variant)</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;variant&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_variant == a_new</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; a_new.cigar_str</span>
<span class="sd">    &#39;=CTA*ca=CCCG&#39;</span>

<span class="sd">    Now one that is mixed (doesn&#39;t match either wildtype or variant):</span>

<span class="sd">    Now one that is mixed (doesn&#39;t match either wildtype or variant):</span>

<span class="sd">    &gt;&gt;&gt; a_mixed = a_wildtype._replace(cigar_str=&#39;=ATACCC*gc=G&#39;)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_mixed)</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;mixed&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_mixed == a_new</span>
<span class="sd">    True</span>

<span class="sd">    Now an alignment that only spans some variable sites:</span>

<span class="sd">    &gt;&gt;&gt; a_var_partial = Alignment(q_st=0, q_en=7, q_len=7, strand=1,</span>
<span class="sd">    ...         r_st=2, r_en=9, r_len=9, score=14, target=&#39;target2&#39;,</span>
<span class="sd">    ...         additional=[], cigar_str=&#39;=TACCC*gc=G&#39;)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_var_partial)</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;partial variant&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_var_partial == a_new</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; a_new.cigar_str</span>
<span class="sd">    &#39;=TACCCCG&#39;</span>

<span class="sd">    Now alignments that do and do not pass the accuracy</span>
<span class="sd">    threshold:</span>

<span class="sd">    &gt;&gt;&gt; a_qvals = Alignment(q_st=1, q_en=9, q_len=9, strand=1,</span>
<span class="sd">    ...         r_st=1, r_en=9, r_len=9, score=16, target=&#39;target2&#39;,</span>
<span class="sd">    ...         additional=[], cigar_str=&#39;=ATACCCGG&#39;)</span>
<span class="sd">    &gt;&gt;&gt; qvals_high = numpy.array([30] * 9)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_qvals, qvals_high)</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;wildtype&#39;</span>
<span class="sd">    &gt;&gt;&gt; qvals_low = numpy.array([30, 10] + [30] * 7)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_qvals, qvals_low)</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;low accuracy&#39;</span>

<span class="sd">    Now an alignment that does not span any variable sites:</span>

<span class="sd">    &gt;&gt;&gt; a_unknown = Alignment(q_st=0, q_en=5, q_len=5, strand=1,</span>
<span class="sd">    ...         r_st=2, r_en=7, r_len=9, score=12, target=&#39;target2&#39;,</span>
<span class="sd">    ...         additional=[], cigar_str=&#39;=TACCC&#39;)</span>
<span class="sd">    &gt;&gt;&gt; (variant, a_new) = targetvars.call(a_unknown)</span>
<span class="sd">    &gt;&gt;&gt; a_unknown == a_new</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; variant</span>
<span class="sd">    &#39;unknown&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variantfiles</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">variantsites_min_acc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class doc string.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variantfiles</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Currently only works for two sets of &quot;</span>
                    <span class="s2">&quot;variants in `variantfiles`.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variantnames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">variantfiles</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variantfiles</span> <span class="o">=</span> <span class="n">variantfiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapper</span> <span class="o">=</span> <span class="n">mapper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetnames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">targetseqs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">variantsites_min_acc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span>
                <span class="n">variantsites_min_acc</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`variantsites_min_acc` must be `None` &quot;</span>
                    <span class="s2">&quot;or between 0 and 1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variantsites_min_acc</span> <span class="o">=</span> <span class="n">variantsites_min_acc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">variant</span><span class="p">,</span> <span class="n">variantfile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variantfiles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="p">[</span><span class="n">variant</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span>
                    <span class="n">Bio</span><span class="o">.</span><span class="n">SeqIO</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">variantfile</span><span class="p">,</span> <span class="s1">&#39;fasta&#39;</span><span class="p">)}</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="p">[</span><span class="n">variant</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The file for variant </span><span class="si">{0}</span><span class="s2"> does not &quot;</span>
                        <span class="s2">&quot;have the expected targets.</span><span class="se">\n</span><span class="s2">Expected: </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Actual: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variant</span><span class="p">,</span>
                        <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetnames</span><span class="p">),</span>
                        <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="p">[</span><span class="n">variant</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="k">for</span> <span class="n">targetname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">targetseqs</span><span class="p">[</span><span class="n">targetname</span><span class="p">])</span> <span class="o">!=</span>
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="p">[</span><span class="n">variant</span><span class="p">][</span><span class="n">targetname</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variant </span><span class="si">{0}</span><span class="s2"> of target </span><span class="si">{1}</span><span class="s2"> is &quot;</span>
                            <span class="s2">&quot;not same length as target in `mapper`. &quot;</span>
                            <span class="s2">&quot;Can&#39;t handle variants that differ by &quot;</span>
                            <span class="s2">&quot;more than point mutations.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">variant</span><span class="p">,</span> <span class="n">targetname</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variablesites</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sitevariants</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variantnames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetnames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variablesites</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variantnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">target</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variantnames</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">target</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sitevariants</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variablesites</span><span class="p">[</span><span class="n">target</span><span class="p">]):</span><span class="n">name</span>
                    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">seqs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sitevariants</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">variant</span><span class="p">:[</span><span class="n">seqs</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variablesites</span><span class="p">[</span><span class="n">target</span><span class="p">]]</span> <span class="k">for</span>
                    <span class="n">variant</span><span class="p">,</span> <span class="n">seqs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<div class="viewcode-block" id="TargetVariants.call"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.TargetVariants.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">qvals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call target variant for an alignment.</span>

<span class="sd">        Args:</span>
<span class="sd">            `a` (:class:`Alignment`)</span>
<span class="sd">                The alignment (built with `mapper`) for which</span>
<span class="sd">                we want to call the target variant.</span>
<span class="sd">            `qvals` (`None` or numpy array)</span>
<span class="sd">                Array of all Q-values for **entire** query used to</span>
<span class="sd">                build alignment, not just aligned region. If not `None`</span>
<span class="sd">                **and** `variantsites_min_acc` attribute is not `None`,</span>
<span class="sd">                then an accuracy requirement is imposed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The 2-tuple `(variant, new_a)`. Possible values are:</span>

<span class="sd">                - If `a` does not cover any of the variable sites,</span>
<span class="sd">                  then `variant` is &quot;unknown&quot; and `new_a` is</span>
<span class="sd">                  just `a`.</span>

<span class="sd">                - If any of the variable sites in `a` don&#39;t meet</span>
<span class="sd">                  the accuracy threshold of `variantsites_min_acc`, then</span>
<span class="sd">                  `variant` is &quot;low accuracy&quot; and `new_a` is just `a`.</span>

<span class="sd">                - If all of the variable sites present in `a` don&#39;t</span>
<span class="sd">                  exactly match one of the variants, then `variant`</span>
<span class="sd">                  is &quot;mixed&quot; and `new_a` is just `a`.</span>

<span class="sd">                - If `a` exactly matches one of the target variants</span>
<span class="sd">                  at all variable sites, then `variant` is a</span>
<span class="sd">                  variant in :class:`TargetVariant.variantnames` and</span>
<span class="sd">                  `new_a` is a version of `a` in which any mismatches</span>
<span class="sd">                  relative to this target variant have been removed</span>
<span class="sd">                  from the :class:`Alignment.cigar_str` attribute.</span>

<span class="sd">                - If `a` only covers some of the variable sites but all</span>
<span class="sd">                  of these match one of the target variants, then</span>
<span class="sd">                  `variant` is &quot;partial &lt;variant&gt;&quot; where &lt;variant&gt;</span>
<span class="sd">                  is a variant in :class:`TargetVariant.variantnames`,</span>
<span class="sd">                  and `new_a` is a version of `a` in which any mismatches</span>
<span class="sd">                  relative to this target variant havea been removed</span>
<span class="sd">                  from the :class:`Alignment.cigar_str` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">strand</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Currently only implemented for + strand&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variablesites</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alignment has unrecognized target </span><span class="si">{0}</span><span class="s2">&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">))</span>

        <span class="n">querysites_w_None</span> <span class="o">=</span> <span class="p">[</span><span class="n">iTargetToQuery</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
        <span class="n">querysites</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">querysites_w_None</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">querysites</span><span class="p">:</span>
            <span class="c1"># no variable sites covered, so can&#39;t call variant</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;unknown&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">qvals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variantsites_min_acc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">q_len</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid length of `qvals`&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dms_tools2</span><span class="o">.</span><span class="n">pacbio</span><span class="o">.</span><span class="n">qvalsToAccuracy</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&lt;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variantsites_min_acc</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qvals</span><span class="p">[</span><span class="n">querysites</span><span class="p">]):</span>
                <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;low accuracy&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="n">query</span> <span class="o">=</span> <span class="n">cigarToQueryAndTarget</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">cigar_str</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">query_idents</span> <span class="o">=</span> <span class="p">[</span><span class="n">query</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">q_st</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">querysites</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">vsites_all</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitevariants</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vsites_all</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">querysites_w_None</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">vsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">nt</span> <span class="k">for</span> <span class="n">nt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vsites_all</span><span class="p">,</span> <span class="n">querysites_w_None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">query_idents</span> <span class="o">==</span> <span class="n">vsites</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vsites_all</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">querysites</span><span class="p">):</span>
                    <span class="n">variant</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variant</span> <span class="o">=</span> <span class="s1">&#39;partial &#39;</span> <span class="o">+</span> <span class="n">v</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitevariants</span>
            <span class="c1"># does not match any of the target variants</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">targetseqs</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">]</span> <span class="o">!=</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variantseqs</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">a</span><span class="o">.</span><span class="n">target</span><span class="p">]):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">querysites_w_None</span><span class="p">)</span>
            <span class="n">targetsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">r_st</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">querysites_w_None</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">targetsites</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_idents</span><span class="p">)</span>
            <span class="n">a_new</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">cigar_str</span><span class="o">=</span><span class="n">removeCIGARmutations</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">cigar_str</span><span class="p">,</span>
                    <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">targetsites</span><span class="p">,</span> <span class="n">query_idents</span><span class="p">))))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">variant</span><span class="p">,</span> <span class="n">a_new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">variant</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span></div></div>


<span class="c1">#: match indels for :meth:`shiftIndels`</span>
<span class="n">_INDELMATCH</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;lead&gt;=[A-Z]+)&#39;</span>
                         <span class="sa">r</span><span class="s1">&#39;(?P&lt;indeltype&gt;[\-\+])&#39;</span>
                         <span class="sa">r</span><span class="s1">&#39;(?P&lt;indel&gt;[a-z]+)&#39;</span>
                         <span class="sa">r</span><span class="s1">&#39;(?P&lt;trail&gt;=[A-Z]+)&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="shiftIndels"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.shiftIndels">[docs]</a><span class="k">def</span> <span class="nf">shiftIndels</span><span class="p">(</span><span class="n">cigar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shifts indels to consistent position.</span>

<span class="sd">    In some cases it is ambiguous where to place insertions /</span>
<span class="sd">    deletions in the CIGAR string. This function moves them</span>
<span class="sd">    to a consistent location (as far forward as possible).</span>

<span class="sd">    Args:</span>
<span class="sd">        `cigar` (str)</span>
<span class="sd">            PAF long CIGAR string, format is</span>
<span class="sd">            `detailed here &lt;https://github.com/lh3/minimap2#cs&gt;`_.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A version of `cigar` with indels shifted as far</span>
<span class="sd">        forward as possible.</span>

<span class="sd">    &gt;&gt;&gt; shiftIndels(&#39;=AAC-atagcc=GGG-ac=T&#39;)</span>
<span class="sd">    &#39;=AA-catagc=CGGG-ac=T&#39;</span>

<span class="sd">    &gt;&gt;&gt; shiftIndels(&#39;=AAC-atagac=GGG-acg=AT&#39;)</span>
<span class="sd">    &#39;=A-acatag=ACGG-gac=GAT&#39;</span>

<span class="sd">    &gt;&gt;&gt; shiftIndels(&#39;=TCC+c=TCAGA+aga=CT&#39;)</span>
<span class="sd">    &#39;=T+c=CCTC+aga=AGACT&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">_INDELMATCH</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">cigar</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="p">])</span>
    <span class="k">while</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">indel</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;indel&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;lead&#39;</span><span class="p">)[</span><span class="o">-</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="p">]</span> <span class="o">==</span> <span class="n">indel</span><span class="p">[</span><span class="o">-</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="p">]:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;lead&#39;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lead</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="c1"># removed entire lead</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lead</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;lead&#39;</span><span class="p">)[</span> <span class="p">:</span> <span class="o">-</span><span class="n">n</span><span class="p">]</span>
            <span class="n">shiftseq</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;lead&#39;</span><span class="p">)[</span><span class="o">-</span><span class="n">n</span> <span class="p">:</span> <span class="p">]</span> <span class="c1"># sequence to shift</span>
            <span class="n">cigar</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
                    <span class="n">cigar</span><span class="p">[</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;lead&#39;</span><span class="p">)],</span> <span class="c1"># sequence before match</span>
                    <span class="n">lead</span><span class="p">,</span> <span class="c1"># remaining portion of lead</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;indeltype&#39;</span><span class="p">),</span>
                    <span class="n">shiftseq</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;indel&#39;</span><span class="p">)[</span> <span class="p">:</span> <span class="o">-</span><span class="n">n</span><span class="p">],</span> <span class="c1"># new indel</span>
                    <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">shiftseq</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;trail&#39;</span><span class="p">)[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">],</span> <span class="c1"># trail after indel</span>
                    <span class="n">cigar</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="s1">&#39;trail&#39;</span><span class="p">)</span> <span class="p">:</span> <span class="p">]</span> <span class="c1"># sequence after match</span>
                    <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;trail&#39;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_INDELMATCH</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">cigar</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="p">])</span>

    <span class="k">return</span> <span class="n">cigar</span></div>


<div class="viewcode-block" id="trimCigar"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.trimCigar">[docs]</a><span class="k">def</span> <span class="nf">trimCigar</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Trims a nucleotide from CIGAR string.</span>

<span class="sd">    Currently just trims one site.</span>

<span class="sd">    Args:</span>
<span class="sd">        `side` (str)</span>
<span class="sd">            &quot;start&quot; trim from start, &quot;end&quot; to trim from end.</span>
<span class="sd">        `cigar` (str)</span>
<span class="sd">            PAF long CIGAR string, format is</span>
<span class="sd">            `detailed here &lt;https://github.com/lh3/minimap2#cs&gt;`_.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A version of `cigar` with a single site trimmed</span>
<span class="sd">        from start or end.</span>

<span class="sd">    &gt;&gt;&gt; trimCigar(&#39;start&#39;, &#39;=ATG&#39;)</span>
<span class="sd">    &#39;=TG&#39;</span>
<span class="sd">    &gt;&gt;&gt; trimCigar(&#39;end&#39;, &#39;=ATG&#39;)</span>
<span class="sd">    &#39;=AT&#39;</span>
<span class="sd">    &gt;&gt;&gt; trimCigar(&#39;start&#39;, &#39;*ac=TG&#39;)</span>
<span class="sd">    &#39;=TG&#39;</span>
<span class="sd">    &gt;&gt;&gt; trimCigar(&#39;end&#39;, &#39;=AT*ag&#39;)</span>
<span class="sd">    &#39;=AT&#39;</span>
<span class="sd">    &gt;&gt;&gt; trimCigar(&#39;start&#39;, &#39;-aac=TG&#39;)</span>
<span class="sd">    &#39;-ac=TG&#39;</span>
<span class="sd">    &gt;&gt;&gt; trimCigar(&#39;end&#39;, &#39;=TG+aac&#39;)</span>
<span class="sd">    &#39;=TG+aa&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;=[A-Z]</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">cigar</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;=[A-Z][\*\-\+]&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*[a-z]</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span><span class="mi">3</span> <span class="p">:</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\-\+][a-z]</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cigar</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\-\+][a-z][^a-z]&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot match start of </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cigar</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;[A-Z]</span><span class="si">{2}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;=[A-Z]$&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span> <span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*[a-z]</span><span class="si">{2}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span> <span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\-\+][a-z]$&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span> <span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;[a-z]</span><span class="si">{2}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cigar</span><span class="p">[</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot match end of </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cigar</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`side` must be &#39;start&#39; or &#39;end&#39;, got </span><span class="si">{0}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">side</span><span class="p">))</span></div>



<div class="viewcode-block" id="parsePAF"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.parsePAF">[docs]</a><span class="k">def</span> <span class="nf">parsePAF</span><span class="p">(</span><span class="n">paf_file</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">introns_to_gaps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse ``*.paf`` file as created by ``minimap2``.</span>

<span class="sd">    `paf_file` is assumed to be created with</span>
<span class="sd">    the ``minimap2`` options ``-c --cs=long``, which</span>
<span class="sd">    creates long `cs` tags with the CIGAR string.</span>

<span class="sd">    PAF format is `described here &lt;https://github.com/lh3/miniasm/blob/master/PAF.md&gt;`_.</span>
<span class="sd">    PAF long CIGAR string format from ``minimap2`` is</span>
<span class="sd">    `detailed here &lt;https://github.com/lh3/minimap2#cs&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        `paf_file` (str or iterator)</span>
<span class="sd">            If str, should be name of ``*.paf`` file.</span>
<span class="sd">            Otherwise should be an iterator that returns</span>
<span class="sd">            lines as would be read from a PAF file.</span>
<span class="sd">        `targets` (dict or `None`)</span>
<span class="sd">            If not `None`, is dict keyed by target names,</span>
<span class="sd">            with values target sequences. You need to provide</span>
<span class="sd">            this if ``minimap2`` is run with a ``--splice``</span>
<span class="sd">            option and `introns_to_gaps` is `True`.</span>
<span class="sd">        `introns_to_gap` (bool)</span>
<span class="sd">            Pass CIGAR strings through :meth:`intronsToGaps`.</span>
<span class="sd">            Requires you to provide `targets`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A generator that yields query / alignments on each line in</span>
<span class="sd">        `paf_file`. Returned as the 2-tuple `(query_name, a)`,</span>
<span class="sd">        where `query_name` is a str giving the name of the query</span>
<span class="sd">        sequence, and `a` is an :class:`Alignment`.</span>

<span class="sd">    Here is a short example:</span>

<span class="sd">    &gt;&gt;&gt; paf_file = io.StringIO(&#39;\\t&#39;.join([</span>
<span class="sd">    ...         &#39;myquery&#39;, &#39;10&#39;, &#39;0&#39;, &#39;10&#39;, &#39;+&#39;, &#39;mytarget&#39;,</span>
<span class="sd">    ...         &#39;20&#39;, &#39;5&#39;, &#39;15&#39;, &#39;9&#39;, &#39;10&#39;, &#39;60&#39;,</span>
<span class="sd">    ...         &#39;cs:Z:=ATG*ga=GAACAT&#39;, &#39;AS:i:7&#39;]))</span>
<span class="sd">    &gt;&gt;&gt; alignments = [tup for tup in parsePAF(paf_file)]</span>
<span class="sd">    &gt;&gt;&gt; len(alignments)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; (queryname, alignment) = alignments[0]</span>
<span class="sd">    &gt;&gt;&gt; queryname</span>
<span class="sd">    &#39;myquery&#39;</span>
<span class="sd">    &gt;&gt;&gt; alignment.target</span>
<span class="sd">    &#39;mytarget&#39;</span>
<span class="sd">    &gt;&gt;&gt; (alignment.r_st, alignment.r_en)</span>
<span class="sd">    (5, 15)</span>
<span class="sd">    &gt;&gt;&gt; (alignment.q_st, alignment.q_en)</span>
<span class="sd">    (0, 10)</span>
<span class="sd">    &gt;&gt;&gt; alignment.strand</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; alignment.cigar_str</span>
<span class="sd">    &#39;=ATG*ga=GAACAT&#39;</span>
<span class="sd">    &gt;&gt;&gt; alignment.q_len</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; alignment.score</span>
<span class="sd">    7</span>

<span class="sd">    Now an example of using `targets` and `introns_to_gaps`.</span>
<span class="sd">    You can see that this option converts the ``~gg5ac``</span>
<span class="sd">    to ``-ggaac`` in the `cigar_str` attribute:</span>

<span class="sd">    &gt;&gt;&gt; targets = {&#39;mytarget&#39;:&#39;ATGGGAACAT&#39;}</span>
<span class="sd">    &gt;&gt;&gt; paf_file = io.StringIO(&#39;\\t&#39;.join([</span>
<span class="sd">    ...         &#39;myquery&#39;, &#39;9&#39;, &#39;0&#39;, &#39;9&#39;, &#39;+&#39;, &#39;mytarget&#39;,</span>
<span class="sd">    ...         &#39;10&#39;, &#39;1&#39;, &#39;10&#39;, &#39;?&#39;, &#39;4&#39;, &#39;60&#39;,</span>
<span class="sd">    ...         &#39;cs:Z:=TG~gg5ac=AT&#39;, &#39;AS:i:2&#39;]))</span>
<span class="sd">    &gt;&gt;&gt; a_keep_introns = [tup for tup in parsePAF(paf_file)][0][1]</span>
<span class="sd">    &gt;&gt;&gt; _ = paf_file.seek(0)</span>
<span class="sd">    &gt;&gt;&gt; a_introns_to_gaps = [tup for tup in parsePAF(paf_file,</span>
<span class="sd">    ...         targets=targets, introns_to_gaps=True)][0][1]</span>
<span class="sd">    &gt;&gt;&gt; a_keep_introns.cigar_str</span>
<span class="sd">    &#39;=TG~gg5ac=AT&#39;</span>
<span class="sd">    &gt;&gt;&gt; a_introns_to_gaps.cigar_str</span>
<span class="sd">    &#39;=TG-ggaac=AT&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">introns_to_gaps</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">targets</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;specify `target` if `introns_to_gaps`:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">targets</span><span class="p">))</span>

    <span class="n">cigar_m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="s1">&#39;cs:Z:(?P&lt;cigar_str&gt;(&#39;</span>
            <span class="sa">r</span><span class="s1">&#39;\*[a-z]</span><span class="si">{2}</span><span class="s1">|&#39;</span> <span class="c1"># matches mutations</span>
            <span class="sa">r</span><span class="s1">&#39;=[A-Z]+|&#39;</span> <span class="c1"># matches identities</span>
            <span class="sa">r</span><span class="s1">&#39;[\+\-][a-z]+|&#39;</span> <span class="c1"># matches indels</span>
            <span class="sa">r</span><span class="s1">&#39;\~[a-z]</span><span class="si">{2}</span><span class="s1">\d+[a-z]</span><span class="si">{2}</span><span class="s1">&#39;</span> <span class="c1"># matches introns</span>
            <span class="sa">r</span><span class="s1">&#39;)+)(?:\s+|$)&#39;</span><span class="p">)</span>
    <span class="n">score_m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;AS:i:(?P&lt;score&gt;[\-\+]?\d+)(?:\s+|$)&#39;</span><span class="p">)</span>

    <span class="n">close_paf_file</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paf_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">paf_file</span><span class="p">),</span> <span class="s2">&quot;no `paf_file` </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">paf_file</span><span class="p">)</span>
        <span class="n">paf_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">paf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">close_paf_file</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paf_file</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`paf_file` must be file name or iterable&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">paf_file</span><span class="p">:</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cigar_str</span> <span class="o">=</span> <span class="n">cigar_m</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;cigar_str&#39;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot match CIGAR:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">12</span><span class="p">]))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">score_m</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;score&#39;</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot match score:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">12</span><span class="p">]))</span>
        <span class="n">query_name</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">r_st</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
        <span class="n">r_en</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">introns_to_gaps</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">targetseq</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;No target </span><span class="si">{0}</span><span class="s2"> in targets&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
            <span class="n">cigar_str</span> <span class="o">=</span> <span class="n">intronsToGaps</span><span class="p">(</span><span class="n">cigar_str</span><span class="p">,</span> <span class="n">targetseq</span><span class="p">[</span><span class="n">r_st</span> <span class="p">:</span> <span class="n">r_en</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Alignment</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                      <span class="n">r_st</span><span class="o">=</span><span class="n">r_st</span><span class="p">,</span>
                      <span class="n">r_en</span><span class="o">=</span><span class="n">r_en</span><span class="p">,</span>
                      <span class="n">r_len</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span>
                      <span class="n">q_st</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                      <span class="n">q_en</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                      <span class="n">q_len</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                      <span class="n">strand</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}[</span><span class="n">entries</span><span class="p">[</span><span class="mi">4</span><span class="p">]],</span>
                      <span class="n">cigar_str</span><span class="o">=</span><span class="n">cigar_str</span><span class="p">,</span>
                      <span class="n">additional</span><span class="o">=</span><span class="p">[],</span>
                      <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">)</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">query_name</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">close_paf_file</span><span class="p">:</span>
        <span class="n">paf_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="c1">#: matches an exact match group in long format CIGAR</span>
<span class="n">_EXACT_MATCH</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;=[A-Z]+&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="numExactMatches"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.numExactMatches">[docs]</a><span class="k">def</span> <span class="nf">numExactMatches</span><span class="p">(</span><span class="n">cigar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Number exactly matched nucleotides in long CIGAR.</span>

<span class="sd">    &gt;&gt;&gt; numExactMatches(&#39;=ATG-aca=A*gc+ac=TAC&#39;)</span>
<span class="sd">    7</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">_EXACT_MATCH</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">cigar</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n</span></div>


<span class="n">_MUTATION_MATCH</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*[a-z]</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="numAligned"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.numAligned">[docs]</a><span class="k">def</span> <span class="nf">numAligned</span><span class="p">(</span><span class="n">cigar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gets number of aligned nucleotides from PAF long CIGAR.</span>

<span class="sd">    Args:</span>
<span class="sd">        `cigar` (str)</span>
<span class="sd">            CIGAR str.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The number of aligned nucleotides in the cigar, where a</span>
<span class="sd">        nucleotide is considered aligned if it is either a</span>
<span class="sd">        match or a point mutation, but not if it is an indel.</span>

<span class="sd">    Example: the CIGAR below has 3 matches, a deletion, 5 matches,</span>
<span class="sd">    2 mutations, 2 matches, an insertion, 3 matches, 1 mutation, and</span>
<span class="sd">    2 matches. So this counts as 3 + 5 + 2 + 2 + 3 + 1 + 2 = 18</span>
<span class="sd">    aligned nucleotides:</span>

<span class="sd">    &gt;&gt;&gt; numAligned(&#39;=ACT-gata=AGTCA*ta*ga=TA+tta=GCA*ca=GT&#39;)</span>
<span class="sd">    18</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">numExactMatches</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span> <span class="o">+</span>
            <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_MUTATION_MATCH</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">cigar</span><span class="p">))))</span></div>



<span class="c1">#: matches individual group in long format CIGAR</span>
<span class="n">_CIGAR_GROUP_MATCH</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;=[A-Z]+|&#39;</span> <span class="c1"># exact matches</span>
                                <span class="sa">r</span><span class="s1">&#39;\*[a-z]</span><span class="si">{2}</span><span class="s1">|&#39;</span> <span class="c1"># mutation</span>
                                <span class="sa">r</span><span class="s1">&#39;[\-\+][a-z]+|&#39;</span> <span class="c1"># indel</span>
                                <span class="sa">r</span><span class="s1">&#39;\~[a-z]</span><span class="si">{2}</span><span class="s1">\d+[a-z]</span><span class="si">{2}</span><span class="s1">&#39;</span> <span class="c1"># intron</span>
                                <span class="p">)</span>


<div class="viewcode-block" id="intronsToGaps"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.intronsToGaps">[docs]</a><span class="k">def</span> <span class="nf">intronsToGaps</span><span class="p">(</span><span class="n">cigar</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts introns to gaps in CIGAR string.</span>

<span class="sd">    If you run ``minimap2``, it reports introns differently</span>
<span class="sd">    than gaps in the target. This function converts</span>
<span class="sd">    the intron notation to gaps. This is useful if you are</span>
<span class="sd">    using the introns as an ad-hoc way to identify</span>
<span class="sd">    long gaps.</span>

<span class="sd">    Args:</span>
<span class="sd">        `cigar` (str)</span>
<span class="sd">            PAF long CIGAR string, format is</span>
<span class="sd">            `detailed here &lt;https://github.com/lh3/minimap2#cs&gt;`_.</span>
<span class="sd">        `target` (str)</span>
<span class="sd">            The exact portion of the target aligned to the query</span>
<span class="sd">            in `cigar`.</span>

<span class="sd">    &gt;&gt;&gt; target = &#39;ATGGAACTAGCATCTAG&#39;</span>
<span class="sd">    &gt;&gt;&gt; cigar = &#39;=A+ca=TG-g=A*ag=CT~ag5at=CTAG&#39;</span>
<span class="sd">    &gt;&gt;&gt; intronsToGaps(cigar, target)</span>
<span class="sd">    &#39;=A+ca=TG-g=A*ag=CT-agcat=CTAG&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newcigar</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># index in target</span>
    <span class="k">while</span> <span class="n">cigar</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_CIGAR_GROUP_MATCH</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;can&#39;t match CIGAR:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
            <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;~&#39;</span><span class="p">:</span>
            <span class="n">intronlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">3</span> <span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">newcigar</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">intronlen</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
            <span class="k">assert</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> \
                    <span class="s2">&quot;target = </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">cigar = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">cigar</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">intronlen</span>
            <span class="k">assert</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span> <span class="p">:</span> <span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">target</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;should never get here&#39;</span><span class="p">)</span>
        <span class="n">cigar</span> <span class="o">=</span> <span class="n">cigar</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">:</span> <span class="p">]</span>

    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">newcigar</span><span class="p">)</span></div>


<div class="viewcode-block" id="cigarToQueryAndTarget"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.cigarToQueryAndTarget">[docs]</a><span class="k">def</span> <span class="nf">cigarToQueryAndTarget</span><span class="p">(</span><span class="n">cigar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns `(query, target)` specified by PAF long CIGAR.</span>

<span class="sd">    Cannot handle CIGAR strings with intron operations.</span>
<span class="sd">    To check those, you first need to run through</span>
<span class="sd">    :meth:`intronsToGaps`.</span>

<span class="sd">    Args:</span>
<span class="sd">        `cigar` (str)</span>
<span class="sd">            CIGAR string.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The 2-tuple `(query, target)`, where each is</span>
<span class="sd">        a string giving the encoded query and target.</span>

<span class="sd">    &gt;&gt;&gt; cigarToQueryAndTarget(&#39;=AT*ac=G+at=AG-ac=T&#39;)</span>
<span class="sd">    (&#39;ATCGATAGT&#39;, &#39;ATAGAGACT&#39;)</span>

<span class="sd">    &gt;&gt;&gt; cigarToQueryAndTarget(&#39;=A+tgc-tgc=AT&#39;)</span>
<span class="sd">    (&#39;ATGCAT&#39;, &#39;ATGCAT&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cigar</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">query</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">target</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">cigar</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_CIGAR_GROUP_MATCH</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;can&#39;t match CIGAR:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">])</span>
            <span class="n">target</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">])</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
            <span class="n">target</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;~&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle intron operations, but.&quot;</span>
                    <span class="s2">&quot;string has one:</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;should never get here&#39;</span><span class="p">)</span>
        <span class="n">cigar</span> <span class="o">=</span> <span class="n">cigar</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">:</span> <span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">query</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target</span><span class="p">))</span></div>


<div class="viewcode-block" id="mutateSeq"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.mutateSeq">[docs]</a><span class="k">def</span> <span class="nf">mutateSeq</span><span class="p">(</span><span class="n">wtseq</span><span class="p">,</span> <span class="n">mutations</span><span class="p">,</span> <span class="n">insertions</span><span class="p">,</span> <span class="n">deletions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mutates sequence and gets CIGAR.</span>

<span class="sd">    Primarily useful for simulations.</span>

<span class="sd">    In the mutation specifications below, 0-based numbering</span>
<span class="sd">    is used. Sequence characters are upper case nucleotides.</span>
<span class="sd">    Operations are applied in the order: mutations, insertions,</span>
<span class="sd">    deletions. So a deletion can overwrite a mutation or insertion.</span>
<span class="sd">    The entire insertion counts as just one added site when indexing</span>
<span class="sd">    the deletions. You will get an error if deletions and insertions</span>
<span class="sd">    overlap.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        `wtseq` (str)</span>
<span class="sd">            The wildtype sequence.</span>
<span class="sd">        `mutations` (list)</span>
<span class="sd">            List of point mutations in form `(i, mut)` where</span>
<span class="sd">            `i` is site and `mut` is mutant amino acid (can be</span>
<span class="sd">            same as wildtype).</span>
<span class="sd">        `deletions` (list)</span>
<span class="sd">            List of deletion locations in form `(istart, iend)`.</span>
<span class="sd">        `insertions` (list)</span>
<span class="sd">            List of insertions in form `(i, seqtoinsert)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The 2-tuple `(mutantseq, cigar)` where `cigar` is the CIGAR</span>
<span class="sd">        in `PAF long format &lt;https://github.com/lh3/minimap2#cs&gt;`_.</span>

<span class="sd">    Here is an example:</span>

<span class="sd">    &gt;&gt;&gt; wtseq = &#39;ATGGAATGA&#39;</span>
<span class="sd">    &gt;&gt;&gt; (mutantseq, cigar) = mutateSeq(wtseq, [], [], [])</span>
<span class="sd">    &gt;&gt;&gt; mutantseq == wtseq</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cigar == &#39;=&#39; + wtseq</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; (mutantseq, cigar) = mutateSeq(wtseq,</span>
<span class="sd">    ...         [(0, &#39;C&#39;), (1, &#39;T&#39;), (3, &#39;A&#39;)],</span>
<span class="sd">    ...         [(8, &#39;TAC&#39;)], [(5, 2)])</span>
<span class="sd">    &gt;&gt;&gt; mutantseq</span>
<span class="sd">    &#39;CTGAAGTACA&#39;</span>
<span class="sd">    &gt;&gt;&gt; cigar</span>
<span class="sd">    &#39;*ac=TG*ga=A-at=G+tac=A&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[</span><span class="si">{0}</span><span class="s1">]+$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">NTS</span><span class="p">)),</span> <span class="n">wtseq</span><span class="p">),</span> \
            <span class="s2">&quot;`wtseq` not all upper case nucleotides.&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wtseq</span><span class="p">)</span>
    <span class="n">mutantseq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">wtseq</span><span class="p">)</span>
    <span class="n">cigar</span> <span class="o">=</span> <span class="n">mutantseq</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mut</span> <span class="ow">in</span> <span class="n">mutations</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
        <span class="k">if</span> <span class="n">mut</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="n">wtseq</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">mutantseq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mut</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">cigar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">wtseq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="n">mut</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># traverse indels from back so index is maintained</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seqtoinsert</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">insertions</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">mutantseq</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">seqtoinsert</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="n">cigar</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span> <span class="o">+</span> <span class="n">seqtoinsert</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">del_len</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">deletions</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">delseq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">del_len</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mutantseq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NTS</span><span class="p">:</span>
                <span class="n">delseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mutantseq</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">mutantseq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="n">delseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mutantseq</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;overlapping insertions and deletions&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">del_len</span><span class="p">):</span>
            <span class="n">mutantseq</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">cigar</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cigar</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">delseq</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="c1"># add equal signs to cigar</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">cigar</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="ow">in</span> <span class="n">NTS</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cigar</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NTS</span><span class="p">):</span>
            <span class="n">cigar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">op</span>

    <span class="n">mutantseq</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mutantseq</span><span class="p">)</span>
    <span class="n">cigar</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mutantseq</span> <span class="o">==</span> <span class="n">cigarToQueryAndTarget</span><span class="p">(</span><span class="n">cigar</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">mutantseq</span><span class="p">,</span> <span class="n">cigar</span><span class="p">)</span></div>


<div class="viewcode-block" id="removeCIGARmutations"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.removeCIGARmutations">[docs]</a><span class="k">def</span> <span class="nf">removeCIGARmutations</span><span class="p">(</span><span class="n">cigar</span><span class="p">,</span> <span class="n">muts_to_remove</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Removes point mutations from CIGAR string.</span>

<span class="sd">    Args:</span>
<span class="sd">        `cigar` (str)</span>
<span class="sd">            Long format CIGAR string.</span>
<span class="sd">        `muts_to_remove` (dict)</span>
<span class="sd">            Dict keyed by site number in 0-based numbering of</span>
<span class="sd">            target starting at first target position in `cigar`,</span>
<span class="sd">            values are nucleotides that we want to make the new</span>
<span class="sd">            target identity for the CIGAR at that site. All</span>
<span class="sd">            of these nucleotides must be the wildtype in the</span>
<span class="sd">            current CIGAR mutation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        New CIGAR string expected if `cigar` was actually to the</span>
<span class="sd">        target where the wildtype identity is what is given by</span>
<span class="sd">        the mutation.</span>

<span class="sd">    &gt;&gt;&gt; cigar = &#39;=AT-gca=T*at=G+ca*ga=T*at&#39;</span>
<span class="sd">    &gt;&gt;&gt; muts_to_remove = {6:&#39;T&#39;, 8:&#39;A&#39;}</span>
<span class="sd">    &gt;&gt;&gt; removeCIGARmutations(cigar, muts_to_remove)</span>
<span class="sd">    &#39;=AT-gca=TTG+ca=AT*at&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_nts</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">nt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">muts_to_remove</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">i_target</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">newcigar</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prevgroupmatch</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">cigar</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_CIGAR_GROUP_MATCH</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">i_target</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="k">if</span> <span class="n">prevgroupmatch</span><span class="p">:</span>
                <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">prevgroupmatch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i_target</span> <span class="ow">in</span> <span class="n">new_nts</span><span class="p">:</span>
                <span class="n">query_nt</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">query_nt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">!=</span> <span class="n">new_nts</span><span class="p">[</span><span class="n">i_target</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not removing mutation&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prevgroupmatch</span><span class="p">:</span>
                    <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_nts</span><span class="p">[</span><span class="n">i_target</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">new_nts</span><span class="p">[</span><span class="n">i_target</span><span class="p">])</span>
                <span class="n">prevgroupmatch</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">del</span> <span class="n">new_nts</span><span class="p">[</span><span class="n">i_target</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
                <span class="n">prevgroupmatch</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">i_target</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">i_target</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">prevgroupmatch</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">newcigar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">prevgroupmatch</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;~&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle intron operations&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;should never get here&quot;</span><span class="p">)</span>
        <span class="n">cigar</span> <span class="o">=</span> <span class="n">cigar</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">:</span> <span class="p">]</span>
    <span class="k">assert</span> <span class="n">cigar</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">new_nts</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;failed to find all mutations to remove&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">newcigar</span><span class="p">)</span></div>


<div class="viewcode-block" id="iTargetToQuery"><a class="viewcode-back" href="../../dms_tools2.minimap2.html#dms_tools2.minimap2.iTargetToQuery">[docs]</a><span class="k">def</span> <span class="nf">iTargetToQuery</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gets index in query aligned to target index.</span>

<span class="sd">    Args:</span>
<span class="sd">        `a` (:class:`Alignment`)</span>
<span class="sd">            The alignment.</span>
<span class="sd">        `i` (int)</span>
<span class="sd">            Index in target in 0-based numbering.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Index in query that aligns to site `i` in target,</span>
<span class="sd">        or `None` if there is not an alignment at that site.</span>

<span class="sd">    &gt;&gt;&gt; a = Alignment(target=&#39;target&#39;, r_st=1, r_en=9, r_len=9,</span>
<span class="sd">    ...         q_st=3, q_en=10, q_len=7, strand=1,</span>
<span class="sd">    ...         cigar_str=&#39;=T*ga=CA-ga=T+c=T&#39;,</span>
<span class="sd">    ...         additional=[], score=-1)</span>
<span class="sd">    &gt;&gt;&gt; iTargetToQuery(a, 0) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; iTargetToQuery(a, 1)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; iTargetToQuery(a, 4)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; iTargetToQuery(a, 6) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; iTargetToQuery(a, 7)</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; iTargetToQuery(a, 8)</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt; iTargetToQuery(a, 9) is None</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">r_st</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">r_en</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">i_query</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">q_st</span>
    <span class="n">i_target</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">r_st</span>
    <span class="n">cigar</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">cigar_str</span>
    <span class="k">while</span> <span class="n">cigar</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_CIGAR_GROUP_MATCH</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_target</span> <span class="o">+</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">i_target</span> <span class="o">-</span> <span class="n">i_query</span><span class="p">)</span>
            <span class="n">i_target</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="n">i_query</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">i_target</span> <span class="o">-</span> <span class="n">i_query</span><span class="p">)</span>
            <span class="n">i_target</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i_query</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_target</span> <span class="o">+</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">i_target</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">i_query</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;~&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle intron operations&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;should never get here&quot;</span><span class="p">)</span>
        <span class="n">cigar</span> <span class="o">=</span> <span class="n">cigar</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">:</span> <span class="p">]</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;should not get here</span><span class="se">\n</span><span class="s2">i=</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">a=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/BloomLogo.jpg" alt="Logo"/>
    
    <h1 class="logo logo-name">dms_tools2</h1>
    
  </a>
</p>



<p class="blurb">Tools for analyzing deep mutational scanning data.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=jbloomlab&repo=dms_tools2&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/jbloomlab/dms_tools2">
    <img
        alt="https://secure.travis-ci.org/jbloomlab/dms_tools2.svg?branch=master"
        src="https://secure.travis-ci.org/jbloomlab/dms_tools2.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bcsubamp.html">Barcoded-subamplicon sequencing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../prefs.html">Amino-acid preferences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../diffsel.html">Differential selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fracsurvive.html">Fraction surviving</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../programs.html">Executable programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citations.html">Citations</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017--2020, the Bloom lab.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/jbloomlab/dms_tools2" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>