#!python

"""Aligns and counts mutations in barcoded subamplicons."""


import os
import sys
import re
import logging
import gzip
import random
import pandas
import Bio.SeqIO
import dms_tools2.parseargs
import dms_tools2.utils



def bcInfo(bc, bcreads, retained, consensus, desc):
    """Returns string for writing to `bcinfofile`.
   
    Creates a string summarizing the barcode.

    Args:
        `bc` (str):
            The barcode.
        `bcreads` (list)
            List of reads for barcode as `(R1, R2)` tuples.
        `retained` (bool)
            Is the barcode retained?
        `consensus` (str or `None`)
            The consensus sequence for the barcode if created.
        `desc` (str)
            String describing the barcode and its fate.

    Returns:
        A string summarizing the barcode.
    """
    return '\n'.join([
            'BARCODE: {0}'.format(bc),
            'RETAINED: {0}'.format(retained),
            'DESCRIPTION: {0}'.format(desc),
            'CONSENSUS: {0}'.format(consensus),
            'READS: {0}'.format('\n\t'.join(['R1 = {0}; R2 = {1}'.format(
                    r1, r2) for (r1, r2) in bcreads])),
            '',
            ])


def main():
    """Main body of script."""

    parser = dms_tools2.parseargs.bcsubampliconsParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    random.seed(args['seed'])

    # set up names of output files
    assert re.search('^[a-zA-Z0-9\-]+$', args['name']), \
            "--name should contain only letters, numbers, and dashes"
    if args['outdir']:
        if not os.path.isdir(args['outdir']):
            os.mkdir(args['outdir'])
    else:
        args['outdir'] = ''
    filesuffixes = {
            'log':'.log',
            'counts':'_counts.csv',
            'summarystats':'_summarystats.csv'
            }
    if args['bcinfo']:
        filesuffixes['bcinfo'] = '_bcinfo.txt.gz'
    files = dict([(f, '{0}/{1}{2}'.format(args['outdir'], args['name'], s))
            for (f, s) in filesuffixes.items()])

    # do we need to proceed?
    if args['use_existing'] and all(map(os.path.isfile, files.values())):
        print("Output files already exist and '--use_existing' specified, "
              "so exiting with no further action.")
        sys.exit(0)

    logger = dms_tools2.utils.initLogger(files['log'], prog, args)

    # log in try / except loop
    try:

        for f in files:
            if os.path.isfile(f):
                logger.info("Removing existing file {0}".format(f))
                os.remove(f)

        assert not (args['purgeread'] and args['purgebc']), ("It does "
                "not make sense to use both --purgeread and --purgebc "
                "as they subsample the data in different ways.")

        # read refseq
        refseq = [s for s in Bio.SeqIO.parse(args['refseq'], 'fasta')]
        assert len(refseq) == 1, "refseq does not specify one sequence" 
        refseq = str(refseq[0].seq).upper()
        if args['chartype'] == 'codon':
            assert re.search('^[{0}]+$'.format(''.join(dms_tools2.NTS)), 
                    refseq), "refseq does not contain only DNA nts"
            assert len(refseq) % 3 == 0, "refseq length not multiple of 3"
            logger.info('Read refseq of {0} codons from {1}'.format(
                    len(refseq), args['refseq']))
        else:
            raise ValueError("Invalid chartype")

        bclen = args['bclen']
        assert bclen > 0, 'bclen not > 0'

        assert 1 >= args['minconcur'] > 0.5
        assert args['minreads'] > 0
        assert 1 >= args['minfraccall'] > 0
        assert args['maxmuts'] >= 1

        # check validity of alignspecs
        alignspecs = []
        for s in args['alignspecs']:
            (refseqstart, refseqend, r1start, r2start) = map(int, s.split(','))
            for (rstart, rname) in [(r1start, 'R1START'), (r2start, 'R2START')]:
                if (bclen > rstart):
                    raise ValueError("alignspecs has {0} of {1}, which "
                            "doesn't fully trim barcode of bclen {2}".format(
                            rname, rstart, bclen))
                assert rstart >= 1, "{0} must be >= 1".format(rname)
            assert refseqend > refseqstart, "REFSEQEND <= REFSEQSTART"
            assert refseqstart >= 0, "REFSEQSTART < 1"
            assert refseqend <= len(refseq), "REFSEQEND > len(refseq)"
            maxN = (refseqend - refseqstart + 1) * (1 - args['minfraccall'])
            # subtract bclen from rstart because barcode trimmed before aligning
            alignspecs.append((refseqstart, refseqend, 
                    r1start - bclen, r2start - bclen, maxN))

        # set up R1 and R2 trims based on alignspecs
        trims = {} # keyed by R1, R2, values are list of trims
        maxtrim = {}
        for r in ['R1', 'R2']:
            trimarg = args['{0}trim'.format(r)]
            if isinstance(trimarg, int):
                trimarg = [trimarg]
            if len(trimarg) == 1:
                trims[r] = [trimarg[0]] * len(alignspecs)
            else:
                trims[r] = trimarg
            assert len(trims[r]) == len(alignspecs), ("--{0}trim must be "
                    "one value or same length as --alignspecs".format(r))
            assert all([t > bclen for t in trims[r]]), ("--{0}trim must "
                    "all be greater than --bclen of {1}".format(r, bclen))
            maxtrim[r] = max(trims[r])
            # we remove barcodes from reads below, so adjust trims
            trims[r] = [t - bclen for t in trims[r]]

        # check on read files
        r1files = args['R1']
        assert all(map(os.path.isfile, r1files)), "Missing R1 files"
        if not args['R2']:
            r2files = []
            for r1 in r1files:
                assert r1.count('_R1') == 1, ("Can't guess R2 file for R1 "
                        "file {0}".format(r1))
                r2files.append(r1.replace('_R1', '_R2'))
        else:
            r2files = args['R2']
            assert len(r1files) == len(r2files), "R1 and R2 must be same length"
        assert all(map(os.path.isfile, r2files)), "Missing R2 files"
        logger.info("Reads are in these FASTQ pairs:\n\t{0}\n".format(
                '\n\t'.join(['{0} and {1}'.format(r1, r2) for (r1, r2) in
                zip(r1files, r2files)])))

        # collect reads by barcode while iterating over reads
        logger.info("Now parsing read pairs...")
        nreads = {
                'total':0,
                'fail filter':0,
                'low Q barcode':0,
            }
        if args['purgeread']:
            nreads['purged'] = 0
            logger.info("Purging read pairs with probability {0:.3f} to "
                    "subsample the data.".format(args['purgeread']))
        minqchar = chr(args['minq'] + 33) # character for Q score cutoff

        barcodes = {} # barcodes key list of (R1, R2) after trimming barcode

        for read_tup in dms_tools2.utils.iteratePairedFASTQ(r1files, r2files,
                    maxtrim['R1'], maxtrim['R2']):

            nreads['total'] += 1
            if nreads['total'] % 1e5 == 0:
                logger.info("Reads parsed so far: {0}".format(nreads['total']))

            if args['purgeread']:
                if random.random() < args['purgeread']:
                    nreads['purged'] += 1
                    continue

            (name, r1, r2, q1, q2, failfilter) = read_tup

            if failfilter:
                nreads['fail filter'] += 1
                continue

            r1 = dms_tools2.utils.lowQtoN(r1, q1, minqchar)
            r2 = dms_tools2.utils.lowQtoN(r2, q2, minqchar)

            barcode = r1[ : bclen] + r2[ : bclen]
            if 'N' in barcode:
                nreads['low Q barcode'] += 1
                continue

            if barcode in barcodes:
                barcodes[barcode].append((r1[bclen : ], r2[bclen : ]))
            else:
                barcodes[barcode] = [(r1[bclen : ], r2[bclen : ])]

        logger.info('Parsed {0} reads, found {1} unique barcodes.\n'.format(
                nreads['total'], len(barcodes)))

        # now loop over barcodes and build / align subamplicons
        nbcs = {
                'total':len(barcodes),
                'too few reads':0,
                'not alignable':0,
                'aligned':0,
               }

        if args['purgebc']:
            logger.info('Purging barcodes with probability {0:.3f}'
                    'to subsample the data.'.format(args['purgebc']))
            nbcs['purged'] = 0
            for barcode in list(barcodes.iterkeys()):
                if random.random() < args['purgefrac']:
                    nbcs['purged'] += 1
                    npurged += 1
                    del barcodes[barcode]
            logger.info('Purged {0} of {1} barcodes ({2:.1f}%%).\n'.format(
                    nbcs['purged'], nbcs['total'], 
                    nbcs['purged'] / float(nbcs['total']) * 100))

        logger.info('Examining the {0} barcodes to see if they can be used '
                'to build alignable subamplicons...'.format(len(barcodes)))

        if args['bcinfo']:
            bcinfofile = gzip.open(args['bcinfo'], 'w')

        for (ibc, (bc, bcreads)) in enumerate(barcodes.items()):

            if ibc % 1e5 == 0:
                logger.info("Barcodes examined so far: {0}".format(ibc))

            if len(bcreads) < args['minreads']:
                print(len(bcreads), args['minreads'])
                nbcs['too few reads'] += 1
                if args['bcinfo']:
                    bcinfofile.write(bcInfo(bc, bcreads, retained=False, 
                            consensus=None, desc='too few reads'))
                continue

            consensus = {}
            for (itup, r) in enumerate(['R1', 'R2']):
                consensus[r] = dms_tools.utils.buildReadConsensus(
                        [tup[itup] for tup in bcreads],
                        args['minreads'], args['minconcur'])

            for (trim, (refseqstart, refseqend, r1start, r2start, maxN)) \
                    in zip(trim, alignspecs):

                trimconsensus = dict([consensus[r][ : trim[r]] for 
                        r in ['R1', 'R2']])

                subamplicon = dms_tools2.utils.alignSubamplicon(refseq,
                        trimconsensus['R1'][r1start - 1 : ], 
                        trimconsensus['R2'][r2start - 1 : ],
                        refseqstart, refseqend, args['maxmuts'],
                        maxN, args['chartype'])

                if subamplicon:
                    if args['bcinfo']:
                       bcinfofile.write(bcInfo(bc, bcreads, retained=True,
                            consensus=subamplicon, desc='aligned at '
                            'position {0}'.format(refseqstart)))
                    nbcs['aligned'] += 1
                    break

            else: # read did not align
                nbcs['not alignable'] += 1
                if args['bcinfo']:
                    bcinfofile.write(bcInfo(bc, bcreads, retained=False,
                            consensus=None, desc='could not align'))

        if args['bcinfo']:
            bcinfofile.close()

        bcstats = pandas.DataFrame(sorted(nbcs.items())).set_index(0)
        logger.info("Examined all barcodes. Summary stats:\n\t{0}".format(
                bcstats.to_csv(sep='\t', header=None).replace('\n', '\n\t')))

        print(barcodes.keys())

    except:
        logger.exception('Terminating {0} with ERROR'.format(prog))
        try:
            bcinfofile.close()
        except:
            pass
        for (fname, fpath) in files.items():
            if fname != 'log' and os.path.isfile(fpath):
                logger.exception("Deleting file {0}".format(fpath))
                os.remove(fpath)

    else:
        logger.info('Successful completion of {0}'.format(prog))

    finally:
        logging.shutdown()


if __name__ == '__main__':
    main() # run the script
